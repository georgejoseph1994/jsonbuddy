{"remainingRequest":"A:\\Z Drive\\OnlineJSONeditor\\OnlineJSONeditor\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!A:\\Z Drive\\OnlineJSONeditor\\OnlineJSONeditor\\node_modules\\jsoneditor\\src\\js\\Node.js","dependencies":[{"path":"A:\\Z Drive\\OnlineJSONeditor\\OnlineJSONeditor\\node_modules\\jsoneditor\\src\\js\\Node.js","mtime":499162500000},{"path":"A:\\Z Drive\\OnlineJSONeditor\\OnlineJSONeditor\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1531646483117},{"path":"A:\\Z Drive\\OnlineJSONeditor\\OnlineJSONeditor\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["'use strict';\n\nvar jmespath = require('jmespath');\nvar naturalSort = require('javascript-natural-sort');\nvar ContextMenu = require('./ContextMenu');\nvar appendNodeFactory = require('./appendNodeFactory');\nvar showMoreNodeFactory = require('./showMoreNodeFactory');\nvar showSortModal = require('./showSortModal');\nvar showTransformModal = require('./showTransformModal');\nvar util = require('./util');\nvar translate = require('./i18n').translate;\n\nvar DEFAULT_MODAL_ANCHOR = document.body; // TODO: this constant is defined twice\n\n/**\n * @constructor Node\n * Create a new Node\n * @param {./treemode} editor\n * @param {Object} [params] Can contain parameters:\n *                          {string}  field\n *                          {boolean} fieldEditable\n *                          {*}       value\n *                          {String}  type  Can have values 'auto', 'array',\n *                                          'object', or 'string'.\n */\nfunction Node (editor, params) {\n  /** @type {./treemode} */\n  this.editor = editor;\n  this.dom = {};\n  this.expanded = false;\n\n  if(params && (params instanceof Object)) {\n    this.setField(params.field, params.fieldEditable);\n    if ('value' in params) {\n      this.setValue(params.value, params.type);\n    }\n    if ('internalValue' in params) {\n      this.setInternalValue(params.internalValue);\n    }\n  }\n  else {\n    this.setField('');\n    this.setValue(null);\n  }\n\n  this._debouncedOnChangeValue = util.debounce(this._onChangeValue.bind(this), Node.prototype.DEBOUNCE_INTERVAL);\n  this._debouncedOnChangeField = util.debounce(this._onChangeField.bind(this), Node.prototype.DEBOUNCE_INTERVAL);\n}\n\n// debounce interval for keyboard input in milliseconds\nNode.prototype.DEBOUNCE_INTERVAL = 150;\n\n// search will stop iterating as soon as the max is reached\nNode.prototype.MAX_SEARCH_RESULTS = 999;\n\n// number of visible childs rendered initially in large arrays/objects (with a \"show more\" button to show more)\nNode.prototype.MAX_VISIBLE_CHILDS = 100;\n\n// default value for the max visible childs of large arrays\nNode.prototype.visibleChilds = Node.prototype.MAX_VISIBLE_CHILDS;\n\n/**\n * Determine whether the field and/or value of this node are editable\n * @private\n */\nNode.prototype._updateEditability = function () {\n  this.editable = {\n    field: true,\n    value: true\n  };\n\n  if (this.editor) {\n    this.editable.field = this.editor.options.mode === 'tree';\n    this.editable.value = this.editor.options.mode !== 'view';\n\n    if ((this.editor.options.mode === 'tree' || this.editor.options.mode === 'form') &&\n        (typeof this.editor.options.onEditable === 'function')) {\n      var editable = this.editor.options.onEditable({\n        field: this.field,\n        value: this.value,\n        path: this.getPath()\n      });\n\n      if (typeof editable === 'boolean') {\n        this.editable.field = editable;\n        this.editable.value = editable;\n      }\n      else {\n        if (typeof editable.field === 'boolean') this.editable.field = editable.field;\n        if (typeof editable.value === 'boolean') this.editable.value = editable.value;\n      }\n    }\n  }\n};\n\n/**\n * Get the path of this node\n * @return {String[]} Array containing the path to this node\n */\nNode.prototype.getPath = function () {\n  var node = this;\n  var path = [];\n  while (node) {\n    var field = node.getName();\n    if (field !== undefined) {\n      path.unshift(field);\n    }\n    node = node.parent;\n  }\n  return path;\n};\n\n/**\n * Get the internal path of this node, a list with the child indexes.\n * @return {String[]} Array containing the internal path to this node\n */\nNode.prototype.getInternalPath = function () {\n  var node = this;\n  var internalPath = [];\n  while (node) {\n    if (node.parent) {\n      internalPath.unshift(node.getIndex());\n    }\n    node = node.parent;\n  }\n  return internalPath;\n};\n\n/**\n * Get node serializable name\n * @returns {String|Number}\n */\nNode.prototype.getName = function () {\n return !this.parent\n ? undefined  // do not add an (optional) field name of the root node\n :  (this.parent.type != 'array')\n     ? this.field\n     : this.index;\n};\n\n/**\n * Find child node by serializable path\n * @param {Array<String>} path \n */\nNode.prototype.findNodeByPath = function (path) {\n  if (!path) {\n    return;\n  }\n\n  if (path.length == 0) {\n    return this;\n  }\n\n  if (path.length && this.childs && this.childs.length) {\n    for (var i=0; i < this.childs.length; ++i) {\n      if (('' + path[0]) === ('' + this.childs[i].getName())) {\n        return this.childs[i].findNodeByPath(path.slice(1));\n      }\n    }\n  }\n};\n\n/**\n * Find child node by an internal path: the indexes of the childs nodes\n * @param {Array<String>} internalPath\n * @return {Node | undefined} Returns the node if the path exists.\n *                            Returns undefined otherwise.\n */\nNode.prototype.findNodeByInternalPath = function (internalPath) {\n  if (!internalPath) {\n    return undefined;\n  }\n\n  var node = this;\n  for (var i = 0; i < internalPath.length && node; i++) {\n    var childIndex = internalPath[i];\n    node = node.childs[childIndex];\n  }\n\n  return node;\n};\n\n/**\n * @typedef {{value: String|Object|Number|Boolean, path: Array.<String|Number>}} SerializableNode\n * \n * Returns serializable representation for the node\n * @return {SerializableNode}\n */\nNode.prototype.serialize = function () {\n  return {\n    value: this.getValue(),\n    path: this.getPath()\n  };\n};\n\n/**\n * Find a Node from a JSON path like '.items[3].name'\n * @param {string} jsonPath\n * @return {Node | null} Returns the Node when found, returns null if not found\n */\nNode.prototype.findNode = function (jsonPath) {\n  var path = util.parsePath(jsonPath);\n  var node = this;\n  while (node && path.length > 0) {\n    var prop = path.shift();\n    if (typeof prop === 'number') {\n      if (node.type !== 'array') {\n        throw new Error('Cannot get child node at index ' + prop + ': node is no array');\n      }\n      node = node.childs[prop];\n    }\n    else { // string\n      if (node.type !== 'object') {\n        throw new Error('Cannot get child node ' + prop + ': node is no object');\n      }\n      node = node.childs.filter(function (child) {\n        return child.field === prop;\n      })[0];\n    }\n  }\n\n  return node;\n};\n\n/**\n * Find all parents of this node. The parents are ordered from root node towards\n * the original node.\n * @return {Array.<Node>}\n */\nNode.prototype.findParents = function () {\n  var parents = [];\n  var parent = this.parent;\n  while (parent) {\n    parents.unshift(parent);\n    parent = parent.parent;\n  }\n  return parents;\n};\n\n/**\n *\n * @param {{dataPath: string, keyword: string, message: string, params: Object, schemaPath: string} | null} error\n * @param {Node} [child]  When this is the error of a parent node, pointing\n *                        to an invalid child node, the child node itself\n *                        can be provided. If provided, clicking the error\n *                        icon will set focus to the invalid child node.\n */\nNode.prototype.setError = function (error, child) {\n  this.error = error;\n  this.errorChild = child;\n\n  if (this.dom && this.dom.tr) {\n    this.updateError()\n  }\n};\n\n/**\n * Render the error\n */\nNode.prototype.updateError = function() {\n  var error = this.error;\n  var tdError = this.dom.tdError;\n  if (error && this.dom && this.dom.tr) {\n    if (!tdError) {\n      tdError = document.createElement('td');\n      this.dom.tdError = tdError;\n      this.dom.tdValue.parentNode.appendChild(tdError);\n    }\n\n    var popover = document.createElement('div');\n    popover.className = 'jsoneditor-popover jsoneditor-right';\n    popover.appendChild(document.createTextNode(error.message));\n\n    var button = document.createElement('button');\n    button.type = 'button';\n    button.className = 'jsoneditor-schema-error';\n    button.appendChild(popover);\n\n    // update the direction of the popover\n    button.onmouseover = button.onfocus = function updateDirection() {\n      var directions = ['right', 'above', 'below', 'left'];\n      for (var i = 0; i < directions.length; i++) {\n        var direction = directions[i];\n        popover.className = 'jsoneditor-popover jsoneditor-' + direction;\n\n        var contentRect = this.editor.content.getBoundingClientRect();\n        var popoverRect = popover.getBoundingClientRect();\n        var margin = 20; // account for a scroll bar\n        var fit = util.insideRect(contentRect, popoverRect, margin);\n\n        if (fit) {\n          break;\n        }\n      }\n    }.bind(this);\n\n    // when clicking the error icon, expand all nodes towards the invalid\n    // child node, and set focus to the child node\n    var child = this.errorChild;\n    if (child) {\n      button.onclick = function showInvalidNode() {\n        child.findParents().forEach(function (parent) {\n          parent.expand(false);\n        });\n\n        child.scrollTo(function () {\n          child.focus();\n        });\n      };\n    }\n\n    // apply the error message to the node\n    while (tdError.firstChild) {\n      tdError.removeChild(tdError.firstChild);\n    }\n    tdError.appendChild(button);\n  }\n  else {\n    if (tdError) {\n      this.dom.tdError.parentNode.removeChild(this.dom.tdError);\n      delete this.dom.tdError;\n    }\n  }\n};\n\n/**\n * Get the index of this node: the index in the list of childs where this\n * node is part of\n * @return {number | null} Returns the index, or null if this is the root node\n */\nNode.prototype.getIndex = function () {\n  if (this.parent) {\n    var index = this.parent.childs.indexOf(this);\n    return index !== -1 ? index : null;\n  }\n  else {\n    return -1;\n  }\n};\n\n/**\n * Set parent node\n * @param {Node} parent\n */\nNode.prototype.setParent = function(parent) {\n  this.parent = parent;\n};\n\n/**\n * Set field\n * @param {String}  field\n * @param {boolean} [fieldEditable]\n */\nNode.prototype.setField = function(field, fieldEditable) {\n  this.field = field;\n  this.previousField = field;\n  this.fieldEditable = (fieldEditable === true);\n};\n\n/**\n * Get field\n * @return {String}\n */\nNode.prototype.getField = function() {\n  if (this.field === undefined) {\n    this._getDomField();\n  }\n\n  return this.field;\n};\n\n/**\n * Set value. Value is a JSON structure or an element String, Boolean, etc.\n * @param {*} value\n * @param {String} [type]  Specify the type of the value. Can be 'auto',\n *                         'array', 'object', or 'string'\n */\nNode.prototype.setValue = function(value, type) {\n  var childValue, child, visible;\n  var i, j;\n  var notUpdateDom = false;\n  var previousChilds = this.childs;\n\n  this.type = this._getType(value);\n\n  // check if type corresponds with the provided type\n  if (type && type !== this.type) {\n    if (type === 'string' && this.type === 'auto') {\n      this.type = type;\n    }\n    else {\n      throw new Error('Type mismatch: ' +\n          'cannot cast value of type \"' + this.type +\n          ' to the specified type \"' + type + '\"');\n    }\n  }\n\n  if (this.type === 'array') {\n    // array\n    if (!this.childs) {\n      this.childs = [];\n    }\n\n    for (i = 0; i < value.length; i++) {\n      childValue = value[i];\n      if (childValue !== undefined && !(childValue instanceof Function)) {\n        if (i < this.childs.length) {\n          // reuse existing child, keep its state\n          child = this.childs[i];\n\n          child.fieldEditable = false;\n          child.index = i;\n          child.setValue(childValue);\n        }\n        else {\n          // create a new child\n          child = new Node(this.editor, {\n            value: childValue\n          });\n          visible = i < this.MAX_VISIBLE_CHILDS;\n          this.appendChild(child, visible, notUpdateDom);\n        }\n      }\n    }\n\n    // cleanup redundant childs\n    // we loop backward to prevent issues with shifting index numbers\n    for (j = this.childs.length; j >= value.length; j--) {\n      this.removeChild(this.childs[j], notUpdateDom);\n    }\n  }\n  else if (this.type === 'object') {\n    // object\n    if (!this.childs) {\n      this.childs = [];\n    }\n\n    // cleanup redundant childs\n    // we loop backward to prevent issues with shifting index numbers\n    for (j = this.childs.length - 1; j >= 0; j--) {\n      if (!value.hasOwnProperty(this.childs[j].field)) {\n        this.removeChild(this.childs[j], notUpdateDom);\n      }\n    }\n\n    i = 0;\n    for (var childField in value) {\n      if (value.hasOwnProperty(childField)) {\n        childValue = value[childField];\n        if (childValue !== undefined && !(childValue instanceof Function)) {\n          child = this.findChildByProperty(childField);\n\n          if (child) {\n            // reuse existing child, keep its state\n            child.setField(childField, true);\n            child.setValue(childValue);\n          }\n          else {\n            // create a new child\n            child = new Node(this.editor, {\n              field: childField,\n              value: childValue\n            });\n            visible = i < this.MAX_VISIBLE_CHILDS;\n            this.appendChild(child, visible, notUpdateDom);\n          }\n        }\n        i++;\n      }\n\n    }\n    this.value = '';\n\n    // sort object keys\n    if (this.editor.options.sortObjectKeys === true) {\n      this.sort([], 'asc');\n    }\n  }\n  else {\n    // value\n    this.hideChilds();\n\n    delete this.append;\n    delete this.showMore;\n    delete this.expanded;\n    delete this.childs;\n\n    this.value = value;\n  }\n\n  // recreate the DOM if switching from an object/array to auto/string or vice versa\n  // needed to recreated the expand button for example\n  if (Array.isArray(previousChilds) !== Array.isArray(this.childs)) {\n    this.recreateDom();\n  }\n\n  this.updateDom({'updateIndexes': true});\n\n  this.previousValue = this.value; // used only to check for changes in DOM vs JS model\n};\n\n/**\n * Set internal value\n * @param {*} internalValue  Internal value structure keeping type,\n *                           order and duplicates in objects\n */\nNode.prototype.setInternalValue = function(internalValue) {\n  var childValue, child, visible;\n  var i, j;\n  var notUpdateDom = false;\n  var previousChilds = this.childs;\n\n  this.type = internalValue.type;\n\n  if (internalValue.type === 'array') {\n    // array\n    if (!this.childs) {\n      this.childs = [];\n    }\n\n    for (i = 0; i < internalValue.childs.length; i++) {\n      childValue = internalValue.childs[i];\n      if (childValue !== undefined && !(childValue instanceof Function)) {\n        if (i < this.childs.length) {\n          // reuse existing child, keep its state\n          child = this.childs[i];\n\n          child.fieldEditable = false;\n          child.index = i;\n          child.setInternalValue(childValue);\n        }\n        else {\n          // create a new child\n          child = new Node(this.editor, {\n            internalValue: childValue\n          });\n          visible = i < this.MAX_VISIBLE_CHILDS;\n          this.appendChild(child, visible, notUpdateDom);\n        }\n      }\n    }\n\n    // cleanup redundant childs\n    // we loop backward to prevent issues with shifting index numbers\n    for (j = this.childs.length; j >= internalValue.childs.length; j--) {\n      this.removeChild(this.childs[j], notUpdateDom);\n    }\n  }\n  else if (internalValue.type === 'object') {\n    // object\n    if (!this.childs) {\n      this.childs = [];\n    }\n\n    for (i = 0; i < internalValue.childs.length; i++) {\n      childValue = internalValue.childs[i];\n      if (childValue !== undefined && !(childValue instanceof Function)) {\n        if (i < this.childs.length) {\n          // reuse existing child, keep its state\n          child = this.childs[i];\n\n          delete child.index;\n          child.setField(childValue.field, true);\n          child.setInternalValue(childValue.value);\n        }\n        else {\n          // create a new child\n          child = new Node(this.editor, {\n            field: childValue.field,\n            internalValue: childValue.value\n          });\n          visible = i < this.MAX_VISIBLE_CHILDS;\n          this.appendChild(child, visible, notUpdateDom);\n        }\n      }\n    }\n\n    // cleanup redundant childs\n    // we loop backward to prevent issues with shifting index numbers\n    for (j = this.childs.length; j >= internalValue.childs.length; j--) {\n      this.removeChild(this.childs[j], notUpdateDom);\n    }\n  }\n  else {\n    // value\n    this.hideChilds();\n\n    delete this.append;\n    delete this.showMore;\n    delete this.expanded;\n    delete this.childs;\n\n    this.value = internalValue.value;\n  }\n\n  // recreate the DOM if switching from an object/array to auto/string or vice versa\n  // needed to recreated the expand button for example\n  if (Array.isArray(previousChilds) !== Array.isArray(this.childs)) {\n    this.recreateDom();\n  }\n\n  this.updateDom({'updateIndexes': true});\n\n  this.previousValue = this.value; // used only to check for changes in DOM vs JS model\n};\n\n/**\n * Remove the DOM of this node and it's childs and recreate it again\n */\nNode.prototype.recreateDom = function() {\n  // only recreate dom if there is a dom already\n  if (!this.dom || ! this.dom.tr || !this.dom.tr.parentNode) {\n    return;\n  }\n\n  var domAnchor = this._detachFromDom();\n\n  // delete the DOM\n  this.clearDom();\n\n  this._attachToDom(domAnchor);\n};\n\n/**\n * Get value. Value is a JSON structure\n * @return {*} value\n */\nNode.prototype.getValue = function() {\n  if (this.type == 'array') {\n    var arr = [];\n    this.childs.forEach (function (child) {\n      arr.push(child.getValue());\n    });\n    return arr;\n  }\n  else if (this.type == 'object') {\n    var obj = {};\n    this.childs.forEach (function (child) {\n      obj[child.getField()] = child.getValue();\n    });\n    return obj;\n  }\n  else {\n    if (this.value === undefined) {\n      this._getDomValue();\n    }\n\n    return this.value;\n  }\n};\n\n/**\n * Get internal value, a structure which maintains ordering and duplicates in objects\n * @return {*} value\n */\nNode.prototype.getInternalValue = function() {\n  if (this.type === 'array') {\n    return {\n      type: this.type,\n      childs: this.childs.map (function (child) {\n        return child.getInternalValue();\n      })\n    };\n  }\n  else if (this.type === 'object') {\n    return {\n      type: this.type,\n      childs: this.childs.map(function (child) {\n        return {\n          field: child.getField(),\n          value: child.getInternalValue()\n        }\n      })\n    };\n  }\n  else {\n    if (this.value === undefined) {\n      this._getDomValue();\n    }\n\n    return {\n      type: this.type,\n      value: this.value\n    };\n  }\n};\n\n/**\n * Get the nesting level of this node\n * @return {Number} level\n */\nNode.prototype.getLevel = function() {\n  return (this.parent ? this.parent.getLevel() + 1 : 0);\n};\n\n/**\n * Get jsonpath of the current node\n * @return {Node[]} Returns an array with nodes\n */\nNode.prototype.getNodePath = function () {\n  var path = this.parent ? this.parent.getNodePath() : [];\n  path.push(this);\n  return path;\n};\n\n/**\n * Create a clone of a node\n * The complete state of a clone is copied, including whether it is expanded or\n * not. The DOM elements are not cloned.\n * @return {Node} clone\n */\nNode.prototype.clone = function() {\n  var clone = new Node(this.editor);\n  clone.type = this.type;\n  clone.field = this.field;\n  clone.fieldInnerText = this.fieldInnerText;\n  clone.fieldEditable = this.fieldEditable;\n  clone.previousField = this.previousField;\n  clone.value = this.value;\n  clone.valueInnerText = this.valueInnerText;\n  clone.previousValue = this.previousValue;\n  clone.expanded = this.expanded;\n  clone.visibleChilds = this.visibleChilds;\n\n  if (this.childs) {\n    // an object or array\n    var cloneChilds = [];\n    this.childs.forEach(function (child) {\n      var childClone = child.clone();\n      childClone.setParent(clone);\n      cloneChilds.push(childClone);\n    });\n    clone.childs = cloneChilds;\n  }\n  else {\n    // a value\n    clone.childs = undefined;\n  }\n\n  return clone;\n};\n\n/**\n * Expand this node and optionally its childs.\n * @param {boolean} [recurse] Optional recursion, true by default. When\n *                            true, all childs will be expanded recursively\n */\nNode.prototype.expand = function(recurse) {\n  if (!this.childs) {\n    return;\n  }\n\n  // set this node expanded\n  this.expanded = true;\n  if (this.dom.expand) {\n    this.dom.expand.className = 'jsoneditor-expanded';\n  }\n\n  this.showChilds();\n\n  if (recurse !== false) {\n    this.childs.forEach(function (child) {\n      child.expand(recurse);\n    });\n  }\n};\n\n/**\n * Collapse this node and optionally its childs.\n * @param {boolean} [recurse] Optional recursion, true by default. When\n *                            true, all childs will be collapsed recursively\n */\nNode.prototype.collapse = function(recurse) {\n  if (!this.childs) {\n    return;\n  }\n\n  this.hideChilds();\n\n  // collapse childs in case of recurse\n  if (recurse !== false) {\n    this.childs.forEach(function (child) {\n      child.collapse(recurse);\n    });\n\n  }\n\n  // make this node collapsed\n  if (this.dom.expand) {\n    this.dom.expand.className = 'jsoneditor-collapsed';\n  }\n  this.expanded = false;\n};\n\n/**\n * Recursively show all childs when they are expanded\n */\nNode.prototype.showChilds = function() {\n  var childs = this.childs;\n  if (!childs) {\n    return;\n  }\n  if (!this.expanded) {\n    return;\n  }\n\n  var tr = this.dom.tr;\n  var table = tr ? tr.parentNode : undefined;\n  if (table) {\n    // show row with append button\n    var append = this.getAppendDom();\n    if (!append.parentNode) {\n      var nextTr = tr.nextSibling;\n      if (nextTr) {\n        table.insertBefore(append, nextTr);\n      }\n      else {\n        table.appendChild(append);\n      }\n    }\n\n    // show childs\n    var iMax = Math.min(this.childs.length, this.visibleChilds);\n    var nextTr = this._getNextTr();\n    for (var i = 0; i < iMax; i++) {\n      var child = this.childs[i];\n      if (!child.getDom().parentNode) {\n        table.insertBefore(child.getDom(), nextTr);\n      }\n      child.showChilds();\n    }\n\n    // show \"show more childs\" if limited\n    var showMore = this.getShowMoreDom();\n    var nextTr = this._getNextTr();\n    if (!showMore.parentNode) {\n      table.insertBefore(showMore, nextTr);\n    }\n    this.showMore.updateDom(); // to update the counter\n  }\n};\n\nNode.prototype._getNextTr = function() {\n  if (this.showMore && this.showMore.getDom().parentNode) {\n    return this.showMore.getDom();\n  }\n\n  if (this.append && this.append.getDom().parentNode) {\n    return this.append.getDom();\n  }\n};\n\n/**\n * Hide the node with all its childs\n * @param {{resetVisibleChilds: boolean}} [options]\n */\nNode.prototype.hide = function(options) {\n  var tr = this.dom.tr;\n  var table = tr ? tr.parentNode : undefined;\n  if (table) {\n    table.removeChild(tr);\n  }\n  this.hideChilds(options);\n};\n\n\n/**\n * Recursively hide all childs\n * @param {{resetVisibleChilds: boolean}} [options]\n */\nNode.prototype.hideChilds = function(options) {\n  var childs = this.childs;\n  if (!childs) {\n    return;\n  }\n  if (!this.expanded) {\n    return;\n  }\n\n  // hide append row\n  var append = this.getAppendDom();\n  if (append.parentNode) {\n    append.parentNode.removeChild(append);\n  }\n\n  // hide childs\n  this.childs.forEach(function (child) {\n    child.hide();\n  });\n\n  // hide \"show more\" row\n  var showMore = this.getShowMoreDom();\n  if (showMore.parentNode) {\n    showMore.parentNode.removeChild(showMore);\n  }\n\n  // reset max visible childs\n  if (!options || options.resetVisibleChilds) {\n    delete this.visibleChilds;\n  }\n};\n\n\n/**\n * Goes through the path from the node to the root and ensures that it is expanded\n */\nNode.prototype.expandTo = function() {\n  var currentNode = this.parent;\n  while (currentNode) {\n    if (!currentNode.expanded) {\n      currentNode.expand();\n    }\n    currentNode = currentNode.parent;\n  }\n};\n\n\n/**\n * Add a new child to the node.\n * Only applicable when Node value is of type array or object\n * @param {Node} node\n * @param {boolean} [visible] If true (default), the child will be rendered\n * @param {boolean} [updateDom]  If true (default), the DOM of both parent\n *                               node and appended node will be updated\n *                               (child count, indexes)\n */\nNode.prototype.appendChild = function(node, visible, updateDom) {\n  if (this._hasChilds()) {\n    // adjust the link to the parent\n    node.setParent(this);\n    node.fieldEditable = (this.type == 'object');\n    if (this.type == 'array') {\n      node.index = this.childs.length;\n    }\n    if (this.type === 'object' && node.field == undefined) {\n      // initialize field value if needed\n      node.setField('');\n    }\n    this.childs.push(node);\n\n    if (this.expanded && visible !== false) {\n      // insert into the DOM, before the appendRow\n      var newTr = node.getDom();\n      var nextTr = this._getNextTr();\n      var table = nextTr ? nextTr.parentNode : undefined;\n      if (nextTr && table) {\n        table.insertBefore(newTr, nextTr);\n      }\n\n      node.showChilds();\n\n      this.visibleChilds++;\n    }\n\n    if (updateDom !== false) {\n      this.updateDom({'updateIndexes': true});\n      node.updateDom({'recurse': true});\n    }\n  }\n};\n\n\n/**\n * Move a node from its current parent to this node\n * Only applicable when Node value is of type array or object\n * @param {Node} node\n * @param {Node} beforeNode\n */\nNode.prototype.moveBefore = function(node, beforeNode) {\n  if (this._hasChilds()) {\n    // create a temporary row, to prevent the scroll position from jumping\n    // when removing the node\n    var tbody = (this.dom.tr) ? this.dom.tr.parentNode : undefined;\n    if (tbody) {\n      var trTemp = document.createElement('tr');\n      trTemp.style.height = tbody.clientHeight + 'px';\n      tbody.appendChild(trTemp);\n    }\n\n    if (node.parent) {\n      node.parent.removeChild(node);\n    }\n\n    if (beforeNode instanceof AppendNode || !beforeNode) {\n      // the this.childs.length + 1 is to reckon with the node that we're about to add\n      if (this.childs.length + 1 > this.visibleChilds) {\n        var lastVisibleNode = this.childs[this.visibleChilds - 1];\n        this.insertBefore(node, lastVisibleNode);\n      }\n      else {\n        this.appendChild(node);\n      }\n    }\n    else {\n      this.insertBefore(node, beforeNode);\n    }\n\n    if (tbody) {\n      tbody.removeChild(trTemp);\n    }\n  }\n};\n\n/**\n * Insert a new child before a given node\n * Only applicable when Node value is of type array or object\n * @param {Node} node\n * @param {Node} beforeNode\n */\nNode.prototype.insertBefore = function(node, beforeNode) {\n  if (this._hasChilds()) {\n    this.visibleChilds++;\n\n    // initialize field value if needed\n    if (this.type === 'object' && node.field == undefined) {\n      node.setField('');\n    }\n\n    if (beforeNode === this.append) {\n      // append to the child nodes\n\n      // adjust the link to the parent\n      node.setParent(this);\n      node.fieldEditable = (this.type == 'object');\n      this.childs.push(node);\n    }\n    else {\n      // insert before a child node\n      var index = this.childs.indexOf(beforeNode);\n      if (index == -1) {\n        throw new Error('Node not found');\n      }\n\n      // adjust the link to the parent\n      node.setParent(this);\n      node.fieldEditable = (this.type == 'object');\n      this.childs.splice(index, 0, node);\n    }\n\n    if (this.expanded) {\n      // insert into the DOM\n      var newTr = node.getDom();\n      var nextTr = beforeNode.getDom();\n      var table = nextTr ? nextTr.parentNode : undefined;\n      if (nextTr && table) {\n        table.insertBefore(newTr, nextTr);\n      }\n\n      node.showChilds();\n      this.showChilds();\n    }\n\n    this.updateDom({'updateIndexes': true});\n    node.updateDom({'recurse': true});\n  }\n};\n\n/**\n * Insert a new child before a given node\n * Only applicable when Node value is of type array or object\n * @param {Node} node\n * @param {Node} afterNode\n */\nNode.prototype.insertAfter = function(node, afterNode) {\n  if (this._hasChilds()) {\n    var index = this.childs.indexOf(afterNode);\n    var beforeNode = this.childs[index + 1];\n    if (beforeNode) {\n      this.insertBefore(node, beforeNode);\n    }\n    else {\n      this.appendChild(node);\n    }\n  }\n};\n\n/**\n * Search in this node\n * Searches are case insensitive.\n * @param {String} text\n * @param {Node[]} [results] Array where search results will be added\n *                           used to count and limit the results whilst iterating\n * @return {Node[]} results  Array with nodes containing the search text\n */\nNode.prototype.search = function(text, results) {\n  if (!Array.isArray(results)) {\n    results = [];\n  }\n  var index;\n  var search = text ? text.toLowerCase() : undefined;\n\n  // delete old search data\n  delete this.searchField;\n  delete this.searchValue;\n\n  // search in field\n  if (this.field !== undefined && results.length <= this.MAX_SEARCH_RESULTS) {\n    var field = String(this.field).toLowerCase();\n    index = field.indexOf(search);\n    if (index !== -1) {\n      this.searchField = true;\n      results.push({\n        'node': this,\n        'elem': 'field'\n      });\n    }\n\n    // update dom\n    this._updateDomField();\n  }\n\n  // search in value\n  if (this._hasChilds()) {\n    // array, object\n\n    // search the nodes childs\n    if (this.childs) {\n      this.childs.forEach(function (child) {\n        child.search(text, results);\n      });\n    }\n  }\n  else {\n    // string, auto\n    if (this.value !== undefined  && results.length <= this.MAX_SEARCH_RESULTS) {\n      var value = String(this.value).toLowerCase();\n      index = value.indexOf(search);\n      if (index !== -1) {\n        this.searchValue = true;\n        results.push({\n          'node': this,\n          'elem': 'value'\n        });\n      }\n\n      // update dom\n      this._updateDomValue();\n    }\n  }\n\n  return results;\n};\n\n/**\n * Move the scroll position such that this node is in the visible area.\n * The node will not get the focus\n * @param {function(boolean)} [callback]\n */\nNode.prototype.scrollTo = function(callback) {\n  this.expandPathToNode();\n\n  if (this.dom.tr && this.dom.tr.parentNode) {\n    this.editor.scrollTo(this.dom.tr.offsetTop, callback);\n  }\n};\n\n/**\n * if the node is not visible, expand its parents\n */\nNode.prototype.expandPathToNode = function () {\n  var node = this;\n  var recurse = false;\n  while (node && node.parent) {\n    // expand visible childs of the parent if needed\n    var index = node.parent.type === 'array'\n        ? node.index\n        : node.parent.childs.indexOf(node);\n    while (node.parent.visibleChilds < index + 1) {\n      node.parent.visibleChilds += Node.prototype.MAX_VISIBLE_CHILDS;\n    }\n\n    // expand the parent itself\n    node.parent.expand(recurse);\n    node = node.parent;\n  }\n};\n\n\n// stores the element name currently having the focus\nNode.focusElement = undefined;\n\n/**\n * Set focus to this node\n * @param {String} [elementName]  The field name of the element to get the\n *                                focus available values: 'drag', 'menu',\n *                                'expand', 'field', 'value' (default)\n */\nNode.prototype.focus = function(elementName) {\n  Node.focusElement = elementName;\n\n  if (this.dom.tr && this.dom.tr.parentNode) {\n    var dom = this.dom;\n\n    switch (elementName) {\n      case 'drag':\n        if (dom.drag) {\n          dom.drag.focus();\n        }\n        else {\n          dom.menu.focus();\n        }\n        break;\n\n      case 'menu':\n        dom.menu.focus();\n        break;\n\n      case 'expand':\n        if (this._hasChilds()) {\n          dom.expand.focus();\n        }\n        else if (dom.field && this.fieldEditable) {\n          dom.field.focus();\n          util.selectContentEditable(dom.field);\n        }\n        else if (dom.value && !this._hasChilds()) {\n          dom.value.focus();\n          util.selectContentEditable(dom.value);\n        }\n        else {\n          dom.menu.focus();\n        }\n        break;\n\n      case 'field':\n        if (dom.field && this.fieldEditable) {\n          dom.field.focus();\n          util.selectContentEditable(dom.field);\n        }\n        else if (dom.value && !this._hasChilds()) {\n          dom.value.focus();\n          util.selectContentEditable(dom.value);\n        }\n        else if (this._hasChilds()) {\n          dom.expand.focus();\n        }\n        else {\n          dom.menu.focus();\n        }\n        break;\n\n      case 'value':\n      default:\n        if (dom.select) {\n          // enum select box\n          dom.select.focus();\n        }\n        else if (dom.value && !this._hasChilds()) {\n          dom.value.focus();\n          util.selectContentEditable(dom.value);\n        }\n        else if (dom.field && this.fieldEditable) {\n          dom.field.focus();\n          util.selectContentEditable(dom.field);\n        }\n        else if (this._hasChilds()) {\n          dom.expand.focus();\n        }\n        else {\n          dom.menu.focus();\n        }\n        break;\n    }\n  }\n};\n\n/**\n * Select all text in an editable div after a delay of 0 ms\n * @param {Element} editableDiv\n */\nNode.select = function(editableDiv) {\n  setTimeout(function () {\n    util.selectContentEditable(editableDiv);\n  }, 0);\n};\n\n/**\n * Update the values from the DOM field and value of this node\n */\nNode.prototype.blur = function() {\n  // retrieve the actual field and value from the DOM.\n  this._getDomValue(false);\n  this._getDomField(false);\n};\n\n/**\n * Check if given node is a child. The method will check recursively to find\n * this node.\n * @param {Node} node\n * @return {boolean} containsNode\n */\nNode.prototype.containsNode = function(node) {\n  if (this == node) {\n    return true;\n  }\n\n  var childs = this.childs;\n  if (childs) {\n    // TODO: use the js5 Array.some() here?\n    for (var i = 0, iMax = childs.length; i < iMax; i++) {\n      if (childs[i].containsNode(node)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n/**\n * Remove a child from the node.\n * Only applicable when Node value is of type array or object\n * @param {Node} node   The child node to be removed;\n * @param {boolean} [updateDom]  If true (default), the DOM of the parent\n *                               node will be updated (like child count)\n * @return {Node | undefined} node  The removed node on success,\n *                                             else undefined\n */\nNode.prototype.removeChild = function(node, updateDom) {\n  if (this.childs) {\n    var index = this.childs.indexOf(node);\n\n    if (index !== -1) {\n      if (index < this.visibleChilds && this.expanded) {\n        this.visibleChilds--;\n      }\n\n      node.hide();\n\n      // delete old search results\n      delete node.searchField;\n      delete node.searchValue;\n\n      var removedNode = this.childs.splice(index, 1)[0];\n      removedNode.parent = null;\n\n      if (updateDom !== false) {\n        this.updateDom({'updateIndexes': true});\n      }\n\n      return removedNode;\n    }\n  }\n\n  return undefined;\n};\n\n/**\n * Remove a child node node from this node\n * This method is equal to Node.removeChild, except that _remove fire an\n * onChange event.\n * @param {Node} node\n * @private\n */\nNode.prototype._remove = function (node) {\n  this.removeChild(node);\n};\n\n/**\n * Change the type of the value of this Node\n * @param {String} newType\n */\nNode.prototype.changeType = function (newType) {\n  var oldType = this.type;\n\n  if (oldType == newType) {\n    // type is not changed\n    return;\n  }\n\n  if ((newType == 'string' || newType == 'auto') &&\n      (oldType == 'string' || oldType == 'auto')) {\n    // this is an easy change\n    this.type = newType;\n  }\n  else {\n    // change from array to object, or from string/auto to object/array\n    var domAnchor = this._detachFromDom();\n\n    // delete the old DOM\n    this.clearDom();\n\n    // adjust the field and the value\n    this.type = newType;\n\n    // adjust childs\n    if (newType == 'object') {\n      if (!this.childs) {\n        this.childs = [];\n      }\n\n      this.childs.forEach(function (child, index) {\n        child.clearDom();\n        delete child.index;\n        child.fieldEditable = true;\n        if (child.field == undefined) {\n          child.field = '';\n        }\n      });\n\n      if (oldType == 'string' || oldType == 'auto') {\n        this.expanded = true;\n      }\n    }\n    else if (newType == 'array') {\n      if (!this.childs) {\n        this.childs = [];\n      }\n\n      this.childs.forEach(function (child, index) {\n        child.clearDom();\n        child.fieldEditable = false;\n        child.index = index;\n      });\n\n      if (oldType == 'string' || oldType == 'auto') {\n        this.expanded = true;\n      }\n    }\n    else {\n      this.expanded = false;\n    }\n\n    this._attachToDom(domAnchor);\n  }\n\n  if (newType == 'auto' || newType == 'string') {\n    // cast value to the correct type\n    if (newType == 'string') {\n      this.value = String(this.value);\n    }\n    else {\n      this.value = this._stringCast(String(this.value));\n    }\n\n    this.focus();\n  }\n\n  this.updateDom({'updateIndexes': true});\n};\n\n/**\n * Test whether the JSON contents of this node are deep equal to provided JSON object.\n * @param {*} json\n */\nNode.prototype.deepEqual = function (json) {\n  var i;\n\n  if (this.type === 'array') {\n    if (!Array.isArray(json)) {\n      return false;\n    }\n\n    if (this.childs.length !== json.length) {\n      return false;\n    }\n\n    for (i = 0; i < this.childs.length; i++) {\n      if (!this.childs[i].deepEqual(json[i])) {\n        return false;\n      }\n    }\n  }\n  else if (this.type === 'object') {\n    if (typeof json !== 'object') {\n      return false;\n    }\n\n    // TODO: for better efficiency, we could create a property `isDuplicate` on all of the childs\n    // and keep that up to date. This should make deepEqual about 20% faster.\n    var props = {};\n    var propCount = 0;\n    for (i = 0; i < this.childs.length; i++) {\n      var child = this.childs[i];\n      if (!props[child.field]) {\n        // We can have childs with duplicate field names.\n        // We take the first, and ignore the others.\n        props[child.field] = true;\n        propCount++;\n\n        if (!(child.field in json)) {\n          return false;\n        }\n\n        if (!child.deepEqual(json[child.field])) {\n          return false;\n        }\n      }\n    }\n\n    if (propCount !== Object.keys(json).length) {\n      return false;\n    }\n  }\n  else {\n    if (this.value !== json) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Retrieve value from DOM\n * @param {boolean} [silent]  If true (default), no errors will be thrown in\n *                            case of invalid data\n * @private\n */\nNode.prototype._getDomValue = function(silent) {\n  if (this.dom.value && this.type != 'array' && this.type != 'object') {\n    this.valueInnerText = util.getInnerText(this.dom.value);\n  }\n\n  if (this.valueInnerText != undefined) {\n    try {\n      // retrieve the value\n      var value;\n      if (this.type == 'string') {\n        value = this._unescapeHTML(this.valueInnerText);\n      }\n      else {\n        var str = this._unescapeHTML(this.valueInnerText);\n        value = this._stringCast(str);\n      }\n      if (value !== this.value) {\n        this.value = value;\n        this._debouncedOnChangeValue();\n      }\n    }\n    catch (err) {\n      this.value = undefined;\n      // TODO: sent an action with the new, invalid value?\n      if (silent !== true) {\n        throw err;\n      }\n    }\n  }\n};\n\n/**\n * Handle a changed value\n * @private\n */\nNode.prototype._onChangeValue = function () {\n  // get current selection, then override the range such that we can select\n  // the added/removed text on undo/redo\n  var oldSelection = this.editor.getDomSelection();\n  if (oldSelection.range) {\n    var undoDiff = util.textDiff(String(this.value), String(this.previousValue));\n    oldSelection.range.startOffset = undoDiff.start;\n    oldSelection.range.endOffset = undoDiff.end;\n  }\n  var newSelection = this.editor.getDomSelection();\n  if (newSelection.range) {\n    var redoDiff = util.textDiff(String(this.previousValue), String(this.value));\n    newSelection.range.startOffset = redoDiff.start;\n    newSelection.range.endOffset = redoDiff.end;\n  }\n\n  this.editor._onAction('editValue', {\n    path: this.getInternalPath(),\n    oldValue: this.previousValue,\n    newValue: this.value,\n    oldSelection: oldSelection,\n    newSelection: newSelection\n  });\n\n  this.previousValue = this.value;\n};\n\n/**\n * Handle a changed field\n * @private\n */\nNode.prototype._onChangeField = function () {\n  // get current selection, then override the range such that we can select\n  // the added/removed text on undo/redo\n  var oldSelection = this.editor.getDomSelection();\n  var previous = this.previousField || '';\n  if (oldSelection.range) {\n    var undoDiff = util.textDiff(this.field, previous);\n    oldSelection.range.startOffset = undoDiff.start;\n    oldSelection.range.endOffset = undoDiff.end;\n  }\n  var newSelection = this.editor.getDomSelection();\n  if (newSelection.range) {\n    var redoDiff = util.textDiff(previous, this.field);\n    newSelection.range.startOffset = redoDiff.start;\n    newSelection.range.endOffset = redoDiff.end;\n  }\n\n  this.editor._onAction('editField', {\n    parentPath: this.parent.getInternalPath(),\n    index: this.getIndex(),\n    oldValue: this.previousField,\n    newValue: this.field,\n    oldSelection: oldSelection,\n    newSelection: newSelection\n  });\n\n  this.previousField = this.field;\n};\n\n/**\n * Update dom value:\n * - the text color of the value, depending on the type of the value\n * - the height of the field, depending on the width\n * - background color in case it is empty\n * @private\n */\nNode.prototype._updateDomValue = function () {\n  var domValue = this.dom.value;\n  if (domValue) {\n    var classNames = ['jsoneditor-value'];\n\n\n    // set text color depending on value type\n    var value = this.value;\n    var type = (this.type == 'auto') ? util.type(value) : this.type;\n    var isUrl = type == 'string' && util.isUrl(value);\n    classNames.push('jsoneditor-' + type);\n    if (isUrl) {\n      classNames.push('jsoneditor-url');\n    }\n\n    // visual styling when empty\n    var isEmpty = (String(this.value) == '' && this.type != 'array' && this.type != 'object');\n    if (isEmpty) {\n      classNames.push('jsoneditor-empty');\n    }\n\n    // highlight when there is a search result\n    if (this.searchValueActive) {\n      classNames.push('jsoneditor-highlight-active');\n    }\n    if (this.searchValue) {\n      classNames.push('jsoneditor-highlight');\n    }\n\n    domValue.className = classNames.join(' ');\n\n    // update title\n    if (type == 'array' || type == 'object') {\n      var count = this.childs ? this.childs.length : 0;\n      domValue.title = this.type + ' containing ' + count + ' items';\n    }\n    else if (isUrl && this.editable.value) {\n      domValue.title = translate('openUrl');\n    }\n    else {\n      domValue.title = '';\n    }\n\n    // show checkbox when the value is a boolean\n    if (type === 'boolean' && this.editable.value) {\n      if (!this.dom.checkbox) {\n        this.dom.checkbox = document.createElement('input');\n        this.dom.checkbox.type = 'checkbox';\n        this.dom.tdCheckbox = document.createElement('td');\n        this.dom.tdCheckbox.className = 'jsoneditor-tree';\n        this.dom.tdCheckbox.appendChild(this.dom.checkbox);\n\n        this.dom.tdValue.parentNode.insertBefore(this.dom.tdCheckbox, this.dom.tdValue);\n      }\n\n      this.dom.checkbox.checked = this.value;\n    }\n    else {\n      // cleanup checkbox when displayed\n      if (this.dom.tdCheckbox) {\n        this.dom.tdCheckbox.parentNode.removeChild(this.dom.tdCheckbox);\n        delete this.dom.tdCheckbox;\n        delete this.dom.checkbox;\n      }\n    }\n\n    if (this.enum && this.editable.value) {\n      // create select box when this node has an enum object\n      if (!this.dom.select) {\n        this.dom.select = document.createElement('select');\n        this.id = this.field + \"_\" + new Date().getUTCMilliseconds();\n        this.dom.select.id = this.id;\n        this.dom.select.name = this.dom.select.id;\n\n        //Create the default empty option\n        this.dom.select.option = document.createElement('option');\n        this.dom.select.option.value = '';\n        this.dom.select.option.innerHTML = '--';\n        this.dom.select.appendChild(this.dom.select.option);\n\n        //Iterate all enum values and add them as options\n        for(var i = 0; i < this.enum.length; i++) {\n          this.dom.select.option = document.createElement('option');\n          this.dom.select.option.value = this.enum[i];\n          this.dom.select.option.innerHTML = this.enum[i];\n          if(this.dom.select.option.value == this.value){\n            this.dom.select.option.selected = true;\n          }\n          this.dom.select.appendChild(this.dom.select.option);\n        }\n\n        this.dom.tdSelect = document.createElement('td');\n        this.dom.tdSelect.className = 'jsoneditor-tree';\n        this.dom.tdSelect.appendChild(this.dom.select);\n        this.dom.tdValue.parentNode.insertBefore(this.dom.tdSelect, this.dom.tdValue);\n      }\n\n      // If the enum is inside a composite type display\n      // both the simple input and the dropdown field\n      if(this.schema && (\n          !this.schema.hasOwnProperty(\"oneOf\") &&\n          !this.schema.hasOwnProperty(\"anyOf\") &&\n          !this.schema.hasOwnProperty(\"allOf\"))\n      ) {\n        this.valueFieldHTML = this.dom.tdValue.innerHTML;\n        this.dom.tdValue.style.visibility = 'hidden';\n        this.dom.tdValue.innerHTML = '';\n      } else {\n        delete this.valueFieldHTML;\n      }\n    }\n    else {\n      // cleanup select box when displayed\n      if (this.dom.tdSelect) {\n        this.dom.tdSelect.parentNode.removeChild(this.dom.tdSelect);\n        delete this.dom.tdSelect;\n        delete this.dom.select;\n        this.dom.tdValue.innerHTML = this.valueFieldHTML;\n        this.dom.tdValue.style.visibility = '';\n        delete this.valueFieldHTML;\n      }\n    }\n\n    // strip formatting from the contents of the editable div\n    util.stripFormatting(domValue);\n  }\n};\n\n/**\n * Update dom field:\n * - the text color of the field, depending on the text\n * - the height of the field, depending on the width\n * - background color in case it is empty\n * @private\n */\nNode.prototype._updateDomField = function () {\n  var domField = this.dom.field;\n  if (domField) {\n    // make backgound color lightgray when empty\n    var isEmpty = (String(this.field) == '' && this.parent.type != 'array');\n    if (isEmpty) {\n      util.addClassName(domField, 'jsoneditor-empty');\n    }\n    else {\n      util.removeClassName(domField, 'jsoneditor-empty');\n    }\n\n    // highlight when there is a search result\n    if (this.searchFieldActive) {\n      util.addClassName(domField, 'jsoneditor-highlight-active');\n    }\n    else {\n      util.removeClassName(domField, 'jsoneditor-highlight-active');\n    }\n    if (this.searchField) {\n      util.addClassName(domField, 'jsoneditor-highlight');\n    }\n    else {\n      util.removeClassName(domField, 'jsoneditor-highlight');\n    }\n\n    // strip formatting from the contents of the editable div\n    util.stripFormatting(domField);\n  }\n};\n\n/**\n * Retrieve field from DOM\n * @param {boolean} [silent]  If true (default), no errors will be thrown in\n *                            case of invalid data\n * @private\n */\nNode.prototype._getDomField = function(silent) {\n  if (this.dom.field && this.fieldEditable) {\n    this.fieldInnerText = util.getInnerText(this.dom.field);\n  }\n\n  if (this.fieldInnerText != undefined) {\n    try {\n      var field = this._unescapeHTML(this.fieldInnerText);\n\n      if (field !== this.field) {\n        this.field = field;\n        this._debouncedOnChangeField();\n      }\n    }\n    catch (err) {\n      this.field = undefined;\n      // TODO: sent an action here, with the new, invalid value?\n      if (silent !== true) {\n        throw err;\n      }\n    }\n  }\n};\n\n/**\n * Validate this node and all it's childs\n * @return {Array.<{node: Node, error: {message: string}}>} Returns a list with duplicates\n */\nNode.prototype.validate = function () {\n  var errors = [];\n\n  // find duplicate keys\n  if (this.type === 'object') {\n    var keys = {};\n    var duplicateKeys = [];\n    for (var i = 0; i < this.childs.length; i++) {\n      var child = this.childs[i];\n      if (keys.hasOwnProperty(child.field)) {\n        duplicateKeys.push(child.field);\n      }\n      keys[child.field] = true;\n    }\n\n    if (duplicateKeys.length > 0) {\n      errors = this.childs\n          .filter(function (node) {\n            return duplicateKeys.indexOf(node.field) !== -1;\n          })\n          .map(function (node) {\n            return {\n              node: node,\n              error: {\n                message: translate('duplicateKey') + ' \"' + node.field + '\"'\n              }\n            }\n          });\n    }\n  }\n\n  // recurse over the childs\n  if (this.childs) {\n    for (var i = 0; i < this.childs.length; i++) {\n      var e = this.childs[i].validate();\n      if (e.length > 0) {\n        errors = errors.concat(e);\n      }\n    }\n  }\n\n  return errors;\n};\n\n/**\n * Clear the dom of the node\n */\nNode.prototype.clearDom = function() {\n  // TODO: hide the node first?\n  //this.hide();\n  // TODO: recursively clear dom?\n\n  this.dom = {};\n};\n\n/**\n * Get the HTML DOM TR element of the node.\n * The dom will be generated when not yet created\n * @return {Element} tr    HTML DOM TR Element\n */\nNode.prototype.getDom = function() {\n  var dom = this.dom;\n  if (dom.tr) {\n    return dom.tr;\n  }\n\n  this._updateEditability();\n\n  // create row\n  dom.tr = document.createElement('tr');\n  dom.tr.node = this;\n\n  if (this.editor.options.mode === 'tree') { // note: we take here the global setting\n    var tdDrag = document.createElement('td');\n    if (this.editable.field) {\n      // create draggable area\n      if (this.parent) {\n        var domDrag = document.createElement('button');\n        domDrag.type = 'button';\n        dom.drag = domDrag;\n        domDrag.className = 'jsoneditor-dragarea';\n        domDrag.title = translate('drag');\n        tdDrag.appendChild(domDrag);\n      }\n    }\n    dom.tr.appendChild(tdDrag);\n\n    // create context menu\n    var tdMenu = document.createElement('td');\n    var menu = document.createElement('button');\n    menu.type = 'button';\n    dom.menu = menu;\n    menu.className = 'jsoneditor-contextmenu';\n    menu.title = translate('actionsMenu');\n    tdMenu.appendChild(dom.menu);\n    dom.tr.appendChild(tdMenu);\n  }\n\n  // create tree and field\n  var tdField = document.createElement('td');\n  dom.tr.appendChild(tdField);\n  dom.tree = this._createDomTree();\n  tdField.appendChild(dom.tree);\n\n  this.updateDom({'updateIndexes': true});\n\n  return dom.tr;\n};\n\n/**\n * Test whether a Node is rendered and visible\n * @returns {boolean}\n */\nNode.prototype.isVisible = function () {\n  return this.dom && this.dom.tr && this.dom.tr.parentNode || false\n};\n\n/**\n * DragStart event, fired on mousedown on the dragarea at the left side of a Node\n * @param {Node[] | Node} nodes\n * @param {Event} event\n */\nNode.onDragStart = function (nodes, event) {\n  if (!Array.isArray(nodes)) {\n    return Node.onDragStart([nodes], event);\n  }\n  if (nodes.length === 0) {\n    return;\n  }\n\n  var firstNode = nodes[0];\n  var lastNode = nodes[nodes.length - 1];\n  var parent = firstNode.parent;\n  var draggedNode = Node.getNodeFromTarget(event.target);\n  var editor = firstNode.editor;\n\n  // in case of multiple selected nodes, offsetY prevents the selection from\n  // jumping when you start dragging one of the lower down nodes in the selection\n  var offsetY = util.getAbsoluteTop(draggedNode.dom.tr) - util.getAbsoluteTop(firstNode.dom.tr);\n\n  if (!editor.mousemove) {\n    editor.mousemove = util.addEventListener(window, 'mousemove', function (event) {\n      Node.onDrag(nodes, event);\n    });\n  }\n\n  if (!editor.mouseup) {\n    editor.mouseup = util.addEventListener(window, 'mouseup',function (event ) {\n      Node.onDragEnd(nodes, event);\n    });\n  }\n\n  editor.highlighter.lock();\n  editor.drag = {\n    oldCursor: document.body.style.cursor,\n    oldSelection: editor.getDomSelection(),\n    oldPaths: nodes.map(getInternalPath),\n    oldParent: parent,\n    oldNextNode: parent.childs[lastNode.getIndex() + 1] || parent.append,\n    oldParentPathRedo: parent.getInternalPath(),\n    oldIndexRedo: firstNode.getIndex(),\n    mouseX: event.pageX,\n    offsetY: offsetY,\n    level: firstNode.getLevel()\n  };\n  document.body.style.cursor = 'move';\n\n  event.preventDefault();\n};\n\n/**\n * Drag event, fired when moving the mouse while dragging a Node\n * @param {Node[] | Node} nodes\n * @param {Event} event\n */\nNode.onDrag = function (nodes, event) {\n  if (!Array.isArray(nodes)) {\n    return Node.onDrag([nodes], event);\n  }\n  if (nodes.length === 0) {\n    return;\n  }\n\n  // TODO: this method has grown too large. Split it in a number of methods\n  var editor = nodes[0].editor;\n  var mouseY = event.pageY - editor.drag.offsetY;\n  var mouseX = event.pageX;\n  var trThis, trPrev, trNext, trFirst, trLast, trRoot;\n  var nodePrev, nodeNext;\n  var topThis, topPrev, topFirst, heightThis, bottomNext, heightNext;\n  var moved = false;\n\n  // TODO: add an ESC option, which resets to the original position\n\n  // move up/down\n  var firstNode = nodes[0];\n  trThis = firstNode.dom.tr;\n  topThis = util.getAbsoluteTop(trThis);\n  heightThis = trThis.offsetHeight;\n  if (mouseY < topThis) {\n    // move up\n    trPrev = trThis;\n    do {\n      trPrev = trPrev.previousSibling;\n      nodePrev = Node.getNodeFromTarget(trPrev);\n      topPrev = trPrev ? util.getAbsoluteTop(trPrev) : 0;\n    }\n    while (trPrev && mouseY < topPrev);\n\n    if (nodePrev && !nodePrev.parent) {\n      nodePrev = undefined;\n    }\n\n    if (!nodePrev) {\n      // move to the first node\n      trRoot = trThis.parentNode.firstChild;\n      trPrev = trRoot ? trRoot.nextSibling : undefined;\n      nodePrev = Node.getNodeFromTarget(trPrev);\n      if (nodePrev == firstNode) {\n        nodePrev = undefined;\n      }\n    }\n\n    if (nodePrev && nodePrev.isVisible()) {\n      // check if mouseY is really inside the found node\n      trPrev = nodePrev.dom.tr;\n      topPrev = trPrev ? util.getAbsoluteTop(trPrev) : 0;\n      if (mouseY > topPrev + heightThis) {\n        nodePrev = undefined;\n      }\n    }\n\n    if (nodePrev) {\n      nodes.forEach(function (node) {\n        nodePrev.parent.moveBefore(node, nodePrev);\n      });\n      moved = true;\n    }\n  }\n  else {\n    // move down\n    var lastNode = nodes[nodes.length - 1];\n    trLast = (lastNode.expanded && lastNode.append) ? lastNode.append.getDom() : lastNode.dom.tr;\n    trFirst = trLast ? trLast.nextSibling : undefined;\n    if (trFirst) {\n      topFirst = util.getAbsoluteTop(trFirst);\n      trNext = trFirst;\n      do {\n        nodeNext = Node.getNodeFromTarget(trNext);\n        if (trNext) {\n          bottomNext = trNext.nextSibling ?\n              util.getAbsoluteTop(trNext.nextSibling) : 0;\n          heightNext = trNext ? (bottomNext - topFirst) : 0;\n\n          if (nodeNext &&\n              nodeNext.parent.childs.length == nodes.length &&\n              nodeNext.parent.childs[nodes.length - 1] == lastNode) {\n            // We are about to remove the last child of this parent,\n            // which will make the parents appendNode visible.\n            topThis += 27;\n            // TODO: dangerous to suppose the height of the appendNode a constant of 27 px.\n          }\n\n          trNext = trNext.nextSibling;\n        }\n      }\n      while (trNext && mouseY > topThis + heightNext);\n\n      if (nodeNext && nodeNext.parent) {\n        // calculate the desired level\n        var diffX = (mouseX - editor.drag.mouseX);\n        var diffLevel = Math.round(diffX / 24 / 2);\n        var level = editor.drag.level + diffLevel; // desired level\n        var levelNext = nodeNext.getLevel();     // level to be\n\n        // find the best fitting level (move upwards over the append nodes)\n        trPrev = nodeNext.dom.tr && nodeNext.dom.tr.previousSibling;\n        while (levelNext < level && trPrev) {\n          nodePrev = Node.getNodeFromTarget(trPrev);\n\n          var isDraggedNode = nodes.some(function (node) {\n            return node === nodePrev || nodePrev.isDescendantOf(node);\n          });\n\n          if (isDraggedNode) {\n            // neglect the dragged nodes themselves and their childs\n          }\n          else if (nodePrev instanceof AppendNode) {\n            var childs = nodePrev.parent.childs;\n            if (childs.length != nodes.length || childs[nodes.length - 1] != lastNode) {\n              // non-visible append node of a list of childs\n              // consisting of not only this node (else the\n              // append node will change into a visible \"empty\"\n              // text when removing this node).\n              nodeNext = Node.getNodeFromTarget(trPrev);\n              levelNext = nodeNext.getLevel();\n            }\n            else {\n              break;\n            }\n          }\n          else {\n            break;\n          }\n\n          trPrev = trPrev.previousSibling;\n        }\n\n        if (nodeNext instanceof AppendNode && !nodeNext.isVisible() &&\n            nodeNext.parent.showMore.isVisible()) {\n          nodeNext = nodeNext._nextNode();\n        }\n\n        // move the node when its position is changed\n        if (nodeNext && nodeNext.dom.tr && trLast.nextSibling != nodeNext.dom.tr) {\n          nodes.forEach(function (node) {\n            nodeNext.parent.moveBefore(node, nodeNext);\n          });\n          moved = true;\n        }\n      }\n    }\n  }\n\n  if (moved) {\n    // update the dragging parameters when moved\n    editor.drag.mouseX = mouseX;\n    editor.drag.level = firstNode.getLevel();\n  }\n\n  // auto scroll when hovering around the top of the editor\n  editor.startAutoScroll(mouseY);\n\n  event.preventDefault();\n};\n\n/**\n * Drag event, fired on mouseup after having dragged a node\n * @param {Node[] | Node} nodes\n * @param {Event} event\n */\nNode.onDragEnd = function (nodes, event) {\n  if (!Array.isArray(nodes)) {\n    return Node.onDrag([nodes], event);\n  }\n  if (nodes.length === 0) {\n    return;\n  }\n\n  var firstNode = nodes[0];\n  var editor = firstNode.editor;\n\n  // set focus to the context menu button of the first node\n  if (nodes[0]) {\n    nodes[0].dom.menu.focus();\n  }\n\n  var oldParentPath = editor.drag.oldParent.getInternalPath();\n  var newParentPath = firstNode.parent.getInternalPath();\n  var sameParent = editor.drag.oldParent === firstNode.parent;\n  var oldIndex = editor.drag.oldNextNode.getIndex();\n  var newIndex = firstNode.getIndex();\n  var oldParentPathRedo = editor.drag.oldParentPathRedo;\n\n  var oldIndexRedo = editor.drag.oldIndexRedo;\n  var newIndexRedo = (sameParent && oldIndexRedo < newIndex)\n      ? (newIndex + nodes.length)\n      : newIndex;\n\n  if (!sameParent || oldIndexRedo !== newIndex) {\n    // only register this action if the node is actually moved to another place\n    editor._onAction('moveNodes', {\n      count: nodes.length,\n      fieldNames: nodes.map(getField),\n\n      oldParentPath: oldParentPath,\n      newParentPath: newParentPath,\n      oldIndex: oldIndex,\n      newIndex: newIndex,\n\n      oldIndexRedo: oldIndexRedo,\n      newIndexRedo: newIndexRedo,\n      oldParentPathRedo: oldParentPathRedo,\n      newParentPathRedo: null, // This is a hack, value will be filled in during undo\n\n      oldSelection: editor.drag.oldSelection,\n      newSelection: editor.getDomSelection()\n    });\n  }\n\n  document.body.style.cursor = editor.drag.oldCursor;\n  editor.highlighter.unlock();\n  nodes.forEach(function (node) {\n    if (event.target !== node.dom.drag && event.target !== node.dom.menu) {\n      editor.highlighter.unhighlight();\n    }\n  });\n  delete editor.drag;\n\n  if (editor.mousemove) {\n    util.removeEventListener(window, 'mousemove', editor.mousemove);\n    delete editor.mousemove;\n  }\n  if (editor.mouseup) {\n    util.removeEventListener(window, 'mouseup', editor.mouseup);\n    delete editor.mouseup;\n  }\n\n  // Stop any running auto scroll\n  editor.stopAutoScroll();\n\n  event.preventDefault();\n};\n\n/**\n * Test if this node is a sescendant of an other node\n * @param {Node} node\n * @return {boolean} isDescendant\n * @private\n */\nNode.prototype.isDescendantOf = function (node) {\n  var n = this.parent;\n  while (n) {\n    if (n == node) {\n      return true;\n    }\n    n = n.parent;\n  }\n\n  return false;\n};\n\n/**\n * Create an editable field\n * @return {Element} domField\n * @private\n */\nNode.prototype._createDomField = function () {\n  return document.createElement('div');\n};\n\n/**\n * Set highlighting for this node and all its childs.\n * Only applied to the currently visible (expanded childs)\n * @param {boolean} highlight\n */\nNode.prototype.setHighlight = function (highlight) {\n  if (this.dom.tr) {\n    if (highlight) {\n      util.addClassName(this.dom.tr, 'jsoneditor-highlight');\n    }\n    else {\n      util.removeClassName(this.dom.tr, 'jsoneditor-highlight');\n    }\n\n    if (this.append) {\n      this.append.setHighlight(highlight);\n    }\n\n    if (this.childs) {\n      this.childs.forEach(function (child) {\n        child.setHighlight(highlight);\n      });\n    }\n  }\n};\n\n/**\n * Select or deselect a node\n * @param {boolean} selected\n * @param {boolean} [isFirst]\n */\nNode.prototype.setSelected = function (selected, isFirst) {\n  this.selected = selected;\n\n  if (this.dom.tr) {\n    if (selected) {\n      util.addClassName(this.dom.tr, 'jsoneditor-selected');\n    }\n    else {\n      util.removeClassName(this.dom.tr, 'jsoneditor-selected');\n    }\n\n    if (isFirst) {\n      util.addClassName(this.dom.tr, 'jsoneditor-first');\n    }\n    else {\n      util.removeClassName(this.dom.tr, 'jsoneditor-first');\n    }\n\n    if (this.append) {\n      this.append.setSelected(selected);\n    }\n\n    if (this.showMore) {\n      this.showMore.setSelected(selected);\n    }\n\n    if (this.childs) {\n      this.childs.forEach(function (child) {\n        child.setSelected(selected);\n      });\n    }\n  }\n};\n\n/**\n * Update the value of the node. Only primitive types are allowed, no Object\n * or Array is allowed.\n * @param {String | Number | Boolean | null} value\n */\nNode.prototype.updateValue = function (value) {\n  this.value = value;\n  this.previousValue = value;\n  this.updateDom();\n};\n\n/**\n * Update the field of the node.\n * @param {String} field\n */\nNode.prototype.updateField = function (field) {\n  this.field = field;\n  this.previousField = field;\n  this.updateDom();\n};\n\n/**\n * Update the HTML DOM, optionally recursing through the childs\n * @param {Object} [options] Available parameters:\n *                          {boolean} [recurse]         If true, the\n *                          DOM of the childs will be updated recursively.\n *                          False by default.\n *                          {boolean} [updateIndexes]   If true, the childs\n *                          indexes of the node will be updated too. False by\n *                          default.\n */\nNode.prototype.updateDom = function (options) {\n  // update level indentation\n  var domTree = this.dom.tree;\n  if (domTree) {\n    domTree.style.marginLeft = this.getLevel() * 24 + 'px';\n  }\n\n  // apply field to DOM\n  var domField = this.dom.field;\n  if (domField) {\n    if (this.fieldEditable) {\n      // parent is an object\n      domField.contentEditable = this.editable.field;\n      domField.spellcheck = false;\n      domField.className = 'jsoneditor-field';\n    }\n    else {\n      // parent is an array this is the root node\n      domField.className = 'jsoneditor-readonly';\n    }\n\n    var fieldText;\n    if (this.index != undefined) {\n      fieldText = this.index;\n    }\n    else if (this.field != undefined) {\n      fieldText = this.field;\n    }\n    else if (this._hasChilds()) {\n      fieldText = this.type;\n    }\n    else {\n      fieldText = '';\n    }\n    domField.innerHTML = this._escapeHTML(fieldText);\n\n    this._updateSchema();\n  }\n\n  // apply value to DOM\n  var domValue = this.dom.value;\n  if (domValue) {\n    var count = this.childs ? this.childs.length : 0;\n    if (this.type == 'array') {\n      domValue.innerHTML = '[' + count + ']';\n      util.addClassName(this.dom.tr, 'jsoneditor-expandable');\n    }\n    else if (this.type == 'object') {\n      domValue.innerHTML = '{' + count + '}';\n      util.addClassName(this.dom.tr, 'jsoneditor-expandable');\n    }\n    else {\n      domValue.innerHTML = this._escapeHTML(this.value);\n      util.removeClassName(this.dom.tr, 'jsoneditor-expandable');\n    }\n  }\n\n  // update field and value\n  this._updateDomField();\n  this._updateDomValue();\n\n  // update childs indexes\n  if (options && options.updateIndexes === true) {\n    // updateIndexes is true or undefined\n    this._updateDomIndexes();\n  }\n\n  // update childs recursively\n  if (options && options.recurse === true) {\n    if (this.childs) {\n      this.childs.forEach(function (child) {\n        child.updateDom(options);\n      });\n    }\n  }\n\n  // update rendering of error\n  if (this.error) {\n    this.updateError()\n  }\n\n  // update row with append button\n  if (this.append) {\n    this.append.updateDom();\n  }\n\n  // update \"show more\" text at the bottom of large arrays\n  if (this.showMore) {\n    this.showMore.updateDom();\n  }\n};\n\n/**\n * Locate the JSON schema of the node and check for any enum type\n * @private\n */\nNode.prototype._updateSchema = function () {\n  //Locating the schema of the node and checking for any enum type\n  if(this.editor && this.editor.options) {\n    // find the part of the json schema matching this nodes path\n    this.schema = this.editor.options.schema \n        ? Node._findSchema(this.editor.options.schema, this.getPath())\n        : null;\n    if (this.schema) {\n      this.enum = Node._findEnum(this.schema);\n    }\n    else {\n      delete this.enum;\n    }\n  }\n};\n\n/**\n * find an enum definition in a JSON schema, as property `enum` or inside\n * one of the schemas composites (`oneOf`, `anyOf`, `allOf`)\n * @param  {Object} schema\n * @return {Array | null} Returns the enum when found, null otherwise.\n * @private\n */\nNode._findEnum = function (schema) {\n  if (schema.enum) {\n    return schema.enum;\n  }\n\n  var composite = schema.oneOf || schema.anyOf || schema.allOf;\n  if (composite) {\n    var match = composite.filter(function (entry) {return entry.enum});\n    if (match.length > 0) {\n      return match[0].enum;\n    }\n  }\n\n  return null\n};\n\n/**\n * Return the part of a JSON schema matching given path.\n * @param {Object} schema\n * @param {Array.<string | number>} path\n * @return {Object | null}\n * @private\n */\nNode._findSchema = function (schema, path) {\n  var childSchema = schema;\n  var foundSchema = childSchema;\n\n  var allSchemas = schema.oneOf || schema.anyOf || schema.allOf;\n  if (!allSchemas) {\n    allSchemas = [schema];\n  }\n\n  for (var j = 0; j < allSchemas.length; j++) {\n    childSchema = allSchemas[j];\n\n    for (var i = 0; i < path.length && childSchema; i++) {\n      var key = path[i];\n\n      if (typeof key === 'string' && childSchema.patternProperties && i == path.length - 1) {\n        for (var prop in childSchema.patternProperties) {\n          foundSchema = Node._findSchema(childSchema.patternProperties[prop], path.slice(i, path.length));\n        }\n      }\n      else if (childSchema.items && childSchema.items.properties) {\n        childSchema = childSchema.items.properties[key];\n        if (childSchema) {\n          foundSchema = Node._findSchema(childSchema, path.slice(i, path.length));\n        }\n      }\n      else if (typeof key === 'string' && childSchema.properties) {\n        childSchema = childSchema.properties[key] || null;\n        if (childSchema) {\n          foundSchema = Node._findSchema(childSchema, path.slice(i, path.length));\n        }\n      }\n      else if (typeof key === 'number' && childSchema.items) {\n        childSchema = childSchema.items;\n        if (childSchema) {\n          foundSchema = Node._findSchema(childSchema, path.slice(i, path.length));\n        }\n      }\n    }\n\n  }\n  return foundSchema\n};\n\n/**\n * Update the DOM of the childs of a node: update indexes and undefined field\n * names.\n * Only applicable when structure is an array or object\n * @private\n */\nNode.prototype._updateDomIndexes = function () {\n  var domValue = this.dom.value;\n  var childs = this.childs;\n  if (domValue && childs) {\n    if (this.type == 'array') {\n      childs.forEach(function (child, index) {\n        child.index = index;\n        var childField = child.dom.field;\n        if (childField) {\n          childField.innerHTML = index;\n        }\n      });\n    }\n    else if (this.type == 'object') {\n      childs.forEach(function (child) {\n        if (child.index != undefined) {\n          delete child.index;\n\n          if (child.field == undefined) {\n            child.field = '';\n          }\n        }\n      });\n    }\n  }\n};\n\n/**\n * Create an editable value\n * @private\n */\nNode.prototype._createDomValue = function () {\n  var domValue;\n\n  if (this.type == 'array') {\n    domValue = document.createElement('div');\n    domValue.innerHTML = '[...]';\n  }\n  else if (this.type == 'object') {\n    domValue = document.createElement('div');\n    domValue.innerHTML = '{...}';\n  }\n  else {\n    if (!this.editable.value && util.isUrl(this.value)) {\n      // create a link in case of read-only editor and value containing an url\n      domValue = document.createElement('a');\n      domValue.href = this.value;\n      domValue.innerHTML = this._escapeHTML(this.value);\n    }\n    else {\n      // create an editable or read-only div\n      domValue = document.createElement('div');\n      domValue.contentEditable = this.editable.value;\n      domValue.spellcheck = false;\n      domValue.innerHTML = this._escapeHTML(this.value);\n    }\n  }\n\n  return domValue;\n};\n\n/**\n * Create an expand/collapse button\n * @return {Element} expand\n * @private\n */\nNode.prototype._createDomExpandButton = function () {\n  // create expand button\n  var expand = document.createElement('button');\n  expand.type = 'button';\n  if (this._hasChilds()) {\n    expand.className = this.expanded ? 'jsoneditor-expanded' : 'jsoneditor-collapsed';\n    expand.title = translate('expandTitle');\n  }\n  else {\n    expand.className = 'jsoneditor-invisible';\n    expand.title = '';\n  }\n\n  return expand;\n};\n\n\n/**\n * Create a DOM tree element, containing the expand/collapse button\n * @return {Element} domTree\n * @private\n */\nNode.prototype._createDomTree = function () {\n  var dom = this.dom;\n  var domTree = document.createElement('table');\n  var tbody = document.createElement('tbody');\n  domTree.style.borderCollapse = 'collapse'; // TODO: put in css\n  domTree.className = 'jsoneditor-values';\n  domTree.appendChild(tbody);\n  var tr = document.createElement('tr');\n  tbody.appendChild(tr);\n\n  // create expand button\n  var tdExpand = document.createElement('td');\n  tdExpand.className = 'jsoneditor-tree';\n  tr.appendChild(tdExpand);\n  dom.expand = this._createDomExpandButton();\n  tdExpand.appendChild(dom.expand);\n  dom.tdExpand = tdExpand;\n\n  // create the field\n  var tdField = document.createElement('td');\n  tdField.className = 'jsoneditor-tree';\n  tr.appendChild(tdField);\n  dom.field = this._createDomField();\n  tdField.appendChild(dom.field);\n  dom.tdField = tdField;\n\n  // create a separator\n  var tdSeparator = document.createElement('td');\n  tdSeparator.className = 'jsoneditor-tree';\n  tr.appendChild(tdSeparator);\n  if (this.type != 'object' && this.type != 'array') {\n    tdSeparator.appendChild(document.createTextNode(':'));\n    tdSeparator.className = 'jsoneditor-separator';\n  }\n  dom.tdSeparator = tdSeparator;\n\n  // create the value\n  var tdValue = document.createElement('td');\n  tdValue.className = 'jsoneditor-tree';\n  tr.appendChild(tdValue);\n  dom.value = this._createDomValue();\n  tdValue.appendChild(dom.value);\n  dom.tdValue = tdValue;\n\n  return domTree;\n};\n\n/**\n * Handle an event. The event is caught centrally by the editor\n * @param {Event} event\n */\nNode.prototype.onEvent = function (event) {\n  var type = event.type,\n      target = event.target || event.srcElement,\n      dom = this.dom,\n      node = this,\n      expandable = this._hasChilds();\n\n  // check if mouse is on menu or on dragarea.\n  // If so, highlight current row and its childs\n  if (target == dom.drag || target == dom.menu) {\n    if (type == 'mouseover') {\n      this.editor.highlighter.highlight(this);\n    }\n    else if (type == 'mouseout') {\n      this.editor.highlighter.unhighlight();\n    }\n  }\n\n  // context menu events\n  if (type == 'click' && target == dom.menu) {\n    var highlighter = node.editor.highlighter;\n    highlighter.highlight(node);\n    highlighter.lock();\n    util.addClassName(dom.menu, 'jsoneditor-selected');\n    this.showContextMenu(dom.menu, function () {\n      util.removeClassName(dom.menu, 'jsoneditor-selected');\n      highlighter.unlock();\n      highlighter.unhighlight();\n    });\n  }\n\n  // expand events\n  if (type == 'click') {\n    if (target == dom.expand ||\n        ((node.editor.options.mode === 'view' || node.editor.options.mode === 'form') && target.nodeName === 'DIV')) {\n      if (expandable) {\n        var recurse = event.ctrlKey; // with ctrl-key, expand/collapse all\n        this._onExpand(recurse);\n      }\n    }\n  }\n\n  // swap the value of a boolean when the checkbox displayed left is clicked\n  if (type == 'change' && target == dom.checkbox) {\n    this.dom.value.innerHTML = !this.value;\n    this._getDomValue();\n  }\n\n  // update the value of the node based on the selected option\n  if (type == 'change' && target == dom.select) {\n    this.dom.value.innerHTML = dom.select.value;\n    this._getDomValue();\n    this._updateDomValue();\n  }\n\n  // value events\n  var domValue = dom.value;\n  if (target == domValue) {\n    //noinspection FallthroughInSwitchStatementJS\n    switch (type) {\n      case 'blur':\n      case 'change':\n        this._getDomValue(true);\n        this._updateDomValue();\n        if (this.value) {\n          domValue.innerHTML = this._escapeHTML(this.value);\n        }\n        break;\n\n      case 'input':\n        //this._debouncedGetDomValue(true); // TODO\n        this._getDomValue(true);\n        this._updateDomValue();\n        break;\n\n      case 'keydown':\n      case 'mousedown':\n          // TODO: cleanup\n        this.editor.selection = this.editor.getDomSelection();\n        break;\n\n      case 'click':\n        if (event.ctrlKey && this.editable.value) {\n          // if read-only, we use the regular click behavior of an anchor\n          if (util.isUrl(this.value)) {\n            event.preventDefault();\n            window.open(this.value, '_blank');\n          }\n        }\n        break;\n\n      case 'keyup':\n        //this._debouncedGetDomValue(true); // TODO\n        this._getDomValue(true);\n        this._updateDomValue();\n        break;\n\n      case 'cut':\n      case 'paste':\n        setTimeout(function () {\n          node._getDomValue(true);\n          node._updateDomValue();\n        }, 1);\n        break;\n    }\n  }\n\n  // field events\n  var domField = dom.field;\n  if (target == domField) {\n    switch (type) {\n      case 'blur':\n      case 'change':\n        this._getDomField(true);\n        this._updateDomField();\n        if (this.field) {\n          domField.innerHTML = this._escapeHTML(this.field);\n        }\n        break;\n\n      case 'input':\n        this._getDomField(true);\n        this._updateSchema();\n        this._updateDomField();\n        this._updateDomValue();\n        break;\n\n      case 'keydown':\n      case 'mousedown':\n        this.editor.selection = this.editor.getDomSelection();\n        break;\n\n      case 'keyup':\n        this._getDomField(true);\n        this._updateDomField();\n        break;\n\n      case 'cut':\n      case 'paste':\n        setTimeout(function () {\n          node._getDomField(true);\n          node._updateDomField();\n        }, 1);\n        break;\n    }\n  }\n\n  // focus\n  // when clicked in whitespace left or right from the field or value, set focus\n  var domTree = dom.tree;\n  if (domTree && target == domTree.parentNode && type == 'click' && !event.hasMoved) {\n    var left = (event.offsetX != undefined) ?\n        (event.offsetX < (this.getLevel() + 1) * 24) :\n        (event.pageX < util.getAbsoluteLeft(dom.tdSeparator));// for FF\n    if (left || expandable) {\n      // node is expandable when it is an object or array\n      if (domField) {\n        util.setEndOfContentEditable(domField);\n        domField.focus();\n      }\n    }\n    else {\n      if (domValue && !this.enum) {\n        util.setEndOfContentEditable(domValue);\n        domValue.focus();\n      }\n    }\n  }\n  if (((target == dom.tdExpand && !expandable) || target == dom.tdField || target == dom.tdSeparator) &&\n      (type == 'click' && !event.hasMoved)) {\n    if (domField) {\n      util.setEndOfContentEditable(domField);\n      domField.focus();\n    }\n  }\n\n  if (type == 'keydown') {\n    this.onKeyDown(event);\n  }\n};\n\n/**\n * Key down event handler\n * @param {Event} event\n */\nNode.prototype.onKeyDown = function (event) {\n  var keynum = event.which || event.keyCode;\n  var target = event.target || event.srcElement;\n  var ctrlKey = event.ctrlKey;\n  var shiftKey = event.shiftKey;\n  var altKey = event.altKey;\n  var handled = false;\n  var prevNode, nextNode, nextDom, nextDom2;\n  var editable = this.editor.options.mode === 'tree';\n  var oldSelection;\n  var oldNextNode;\n  var oldParent;\n  var oldIndexRedo;\n  var newIndexRedo;\n  var oldParentPathRedo;\n  var newParentPathRedo;\n  var nodes;\n  var multiselection;\n  var selectedNodes = this.editor.multiselection.nodes.length > 0\n      ? this.editor.multiselection.nodes\n      : [this];\n  var firstNode = selectedNodes[0];\n  var lastNode = selectedNodes[selectedNodes.length - 1];\n\n  // console.log(ctrlKey, keynum, event.charCode); // TODO: cleanup\n  if (keynum == 13) { // Enter\n    if (target == this.dom.value) {\n      if (!this.editable.value || event.ctrlKey) {\n        if (util.isUrl(this.value)) {\n          window.open(this.value, '_blank');\n          handled = true;\n        }\n      }\n    }\n    else if (target == this.dom.expand) {\n      var expandable = this._hasChilds();\n      if (expandable) {\n        var recurse = event.ctrlKey; // with ctrl-key, expand/collapse all\n        this._onExpand(recurse);\n        target.focus();\n        handled = true;\n      }\n    }\n  }\n  else if (keynum == 68) {  // D\n    if (ctrlKey && editable) {   // Ctrl+D\n      Node.onDuplicate(selectedNodes);\n      handled = true;\n    }\n  }\n  else if (keynum == 69) { // E\n    if (ctrlKey) {       // Ctrl+E and Ctrl+Shift+E\n      this._onExpand(shiftKey);  // recurse = shiftKey\n      target.focus(); // TODO: should restore focus in case of recursing expand (which takes DOM offline)\n      handled = true;\n    }\n  }\n  else if (keynum == 77 && editable) { // M\n    if (ctrlKey) { // Ctrl+M\n      this.showContextMenu(target);\n      handled = true;\n    }\n  }\n  else if (keynum == 46 && editable) { // Del\n    if (ctrlKey) {       // Ctrl+Del\n      Node.onRemove(selectedNodes);\n      handled = true;\n    }\n  }\n  else if (keynum == 45 && editable) { // Ins\n    if (ctrlKey && !shiftKey) {       // Ctrl+Ins\n      this._onInsertBefore();\n      handled = true;\n    }\n    else if (ctrlKey && shiftKey) {   // Ctrl+Shift+Ins\n      this._onInsertAfter();\n      handled = true;\n    }\n  }\n  else if (keynum == 35) { // End\n    if (altKey) { // Alt+End\n      // find the last node\n      var endNode = this._lastNode();\n      if (endNode) {\n        endNode.focus(Node.focusElement || this._getElementName(target));\n      }\n      handled = true;\n    }\n  }\n  else if (keynum == 36) { // Home\n    if (altKey) { // Alt+Home\n      // find the first node\n      var homeNode = this._firstNode();\n      if (homeNode) {\n        homeNode.focus(Node.focusElement || this._getElementName(target));\n      }\n      handled = true;\n    }\n  }\n  else if (keynum == 37) {        // Arrow Left\n    if (altKey && !shiftKey) {  // Alt + Arrow Left\n      // move to left element\n      var prevElement = this._previousElement(target);\n      if (prevElement) {\n        this.focus(this._getElementName(prevElement));\n      }\n      handled = true;\n    }\n    else if (altKey && shiftKey && editable) { // Alt + Shift + Arrow left\n      if (lastNode.expanded) {\n        var appendDom = lastNode.getAppendDom();\n        nextDom = appendDom ? appendDom.nextSibling : undefined;\n      }\n      else {\n        var dom = lastNode.getDom();\n        nextDom = dom.nextSibling;\n      }\n      if (nextDom) {\n        nextNode = Node.getNodeFromTarget(nextDom);\n        nextDom2 = nextDom.nextSibling;\n        nextNode2 = Node.getNodeFromTarget(nextDom2);\n        if (nextNode && nextNode instanceof AppendNode &&\n            !(lastNode.parent.childs.length == 1) &&\n            nextNode2 && nextNode2.parent) {\n          oldSelection = this.editor.getDomSelection();\n          oldParent = firstNode.parent;\n          oldNextNode = oldParent.childs[lastNode.getIndex() + 1] || oldParent.append;\n          oldIndexRedo = firstNode.getIndex();\n          newIndexRedo = nextNode2.getIndex();\n          oldParentPathRedo = oldParent.getInternalPath();\n          newParentPathRedo = nextNode2.parent.getInternalPath();\n\n          selectedNodes.forEach(function (node) {\n            nextNode2.parent.moveBefore(node, nextNode2);\n          });\n          this.focus(Node.focusElement || this._getElementName(target));\n\n\n          this.editor._onAction('moveNodes', {\n            count: selectedNodes.length,\n            fieldNames: selectedNodes.map(getField),\n\n            oldParentPath: oldParent.getInternalPath(),\n            newParentPath: firstNode.parent.getInternalPath(),\n            oldIndex: oldNextNode.getIndex(),\n            newIndex: firstNode.getIndex(),\n\n            oldIndexRedo: oldIndexRedo,\n            newIndexRedo: newIndexRedo,\n            oldParentPathRedo: oldParentPathRedo,\n            newParentPathRedo: newParentPathRedo,\n\n            oldSelection: oldSelection,\n            newSelection: this.editor.getDomSelection()\n          });\n        }\n      }\n    }\n  }\n  else if (keynum == 38) {        // Arrow Up\n    if (altKey && !shiftKey) {  // Alt + Arrow Up\n      // find the previous node\n      prevNode = this._previousNode();\n      if (prevNode) {\n        this.editor.deselect(true);\n        prevNode.focus(Node.focusElement || this._getElementName(target));\n      }\n      handled = true;\n    }\n    else if (!altKey && ctrlKey && shiftKey && editable) { // Ctrl + Shift + Arrow Up\n      // select multiple nodes\n      prevNode = this._previousNode();\n      if (prevNode) {\n        multiselection = this.editor.multiselection;\n        multiselection.start = multiselection.start || this;\n        multiselection.end = prevNode;\n        nodes = this.editor._findTopLevelNodes(multiselection.start, multiselection.end);\n\n        this.editor.select(nodes);\n        prevNode.focus('field'); // select field as we know this always exists\n      }\n      handled = true;\n    }\n    else if (altKey && shiftKey && editable) { // Alt + Shift + Arrow Up\n      // find the previous node\n      prevNode = firstNode._previousNode();\n      if (prevNode && prevNode.parent) {\n        oldSelection = this.editor.getDomSelection();\n        oldParent = firstNode.parent;\n        oldNextNode = oldParent.childs[lastNode.getIndex() + 1] || oldParent.append;\n        oldIndexRedo = firstNode.getIndex();\n        newIndexRedo = prevNode.getIndex();\n        oldParentPathRedo = oldParent.getInternalPath();\n        newParentPathRedo = prevNode.parent.getInternalPath();\n\n        selectedNodes.forEach(function (node) {\n          prevNode.parent.moveBefore(node, prevNode);\n        });\n        this.focus(Node.focusElement || this._getElementName(target));\n\n        this.editor._onAction('moveNodes', {\n          count: selectedNodes.length,\n          fieldNames: selectedNodes.map(getField),\n\n          oldParentPath: oldParent.getInternalPath(),\n          newParentPath: firstNode.parent.getInternalPath(),\n          oldIndex: oldNextNode.getIndex(),\n          newIndex: firstNode.getIndex(),\n\n          oldIndexRedo: oldIndexRedo,\n          newIndexRedo: newIndexRedo,\n          oldParentPathRedo: oldParentPathRedo,\n          newParentPathRedo: newParentPathRedo,\n\n          oldSelection: oldSelection,\n          newSelection: this.editor.getDomSelection()\n        });\n      }\n      handled = true;\n    }\n  }\n  else if (keynum == 39) {        // Arrow Right\n    if (altKey && !shiftKey) {  // Alt + Arrow Right\n      // move to right element\n      var nextElement = this._nextElement(target);\n      if (nextElement) {\n        this.focus(this._getElementName(nextElement));\n      }\n      handled = true;\n    }\n    else if (altKey && shiftKey && editable) { // Alt + Shift + Arrow Right\n      dom = firstNode.getDom();\n      var prevDom = dom.previousSibling;\n      if (prevDom) {\n        prevNode = Node.getNodeFromTarget(prevDom);\n        if (prevNode && prevNode.parent && !prevNode.isVisible()) {\n          oldSelection = this.editor.getDomSelection();\n          oldParent = firstNode.parent;\n          oldNextNode = oldParent.childs[lastNode.getIndex() + 1] || oldParent.append;\n          oldIndexRedo = firstNode.getIndex();\n          newIndexRedo = prevNode.getIndex();\n          oldParentPathRedo = oldParent.getInternalPath();\n          newParentPathRedo = prevNode.parent.getInternalPath();\n\n          selectedNodes.forEach(function (node) {\n            prevNode.parent.moveBefore(node, prevNode);\n          });\n          this.focus(Node.focusElement || this._getElementName(target));\n\n          this.editor._onAction('moveNodes', {\n            count: selectedNodes.length,\n            fieldNames: selectedNodes.map(getField),\n\n            oldParentPath: oldParent.getInternalPath(),\n            newParentPath: firstNode.parent.getInternalPath(),\n            oldIndex: oldNextNode.getIndex(),\n            newIndex: firstNode.getIndex(),\n\n            oldIndexRedo: oldIndexRedo,\n            newIndexRedo: newIndexRedo,\n            oldParentPathRedo: oldParentPathRedo,\n            newParentPathRedo: newParentPathRedo,\n\n            oldSelection: oldSelection,\n            newSelection: this.editor.getDomSelection()\n          });\n        }\n      }\n    }\n  }\n  else if (keynum == 40) {        // Arrow Down\n    if (altKey && !shiftKey) {  // Alt + Arrow Down\n      // find the next node\n      nextNode = this._nextNode();\n      if (nextNode) {\n        this.editor.deselect(true);\n        nextNode.focus(Node.focusElement || this._getElementName(target));\n      }\n      handled = true;\n    }\n    else if (!altKey && ctrlKey && shiftKey && editable) { // Ctrl + Shift + Arrow Down\n      // select multiple nodes\n      nextNode = this._nextNode();\n      if (nextNode) {\n        multiselection = this.editor.multiselection;\n        multiselection.start = multiselection.start || this;\n        multiselection.end = nextNode;\n        nodes = this.editor._findTopLevelNodes(multiselection.start, multiselection.end);\n\n        this.editor.select(nodes);\n        nextNode.focus('field'); // select field as we know this always exists\n      }\n      handled = true;\n    }\n    else if (altKey && shiftKey && editable) { // Alt + Shift + Arrow Down\n      // find the 2nd next node and move before that one\n      if (lastNode.expanded) {\n        nextNode = lastNode.append ? lastNode.append._nextNode() : undefined;\n      }\n      else {\n        nextNode = lastNode._nextNode();\n      }\n\n      // when the next node is not visible, we've reached the \"showMore\" buttons\n      if (nextNode && !nextNode.isVisible()) {\n        nextNode = nextNode.parent.showMore;\n      }\n\n      if (nextNode && nextNode instanceof AppendNode) {\n        nextNode = lastNode;\n      }\n\n      var nextNode2 = nextNode && (nextNode._nextNode() || nextNode.parent.append);\n      if (nextNode2 && nextNode2.parent) {\n        oldSelection = this.editor.getDomSelection();\n        oldParent = firstNode.parent;\n        oldNextNode = oldParent.childs[lastNode.getIndex() + 1] || oldParent.append;\n        oldIndexRedo = firstNode.getIndex();\n        newIndexRedo = nextNode2.getIndex();\n        oldParentPathRedo = oldParent.getInternalPath();\n        newParentPathRedo = nextNode2.parent.getInternalPath();\n\n        selectedNodes.forEach(function (node) {\n          nextNode2.parent.moveBefore(node, nextNode2);\n        });\n        this.focus(Node.focusElement || this._getElementName(target));\n\n        this.editor._onAction('moveNodes', {\n          count: selectedNodes.length,\n          fieldNames: selectedNodes.map(getField),\n          oldParentPath: oldParent.getInternalPath(),\n          newParentPath: firstNode.parent.getInternalPath(),\n          oldParentPathRedo: oldParentPathRedo,\n          newParentPathRedo: newParentPathRedo,\n          oldIndexRedo: oldIndexRedo,\n          newIndexRedo: newIndexRedo,\n          oldIndex: oldNextNode.getIndex(),\n          newIndex: firstNode.getIndex(),\n          oldSelection: oldSelection,\n          newSelection: this.editor.getDomSelection()\n        });\n      }\n      handled = true;\n    }\n  }\n\n  if (handled) {\n    event.preventDefault();\n    event.stopPropagation();\n  }\n};\n\n/**\n * Handle the expand event, when clicked on the expand button\n * @param {boolean} recurse   If true, child nodes will be expanded too\n * @private\n */\nNode.prototype._onExpand = function (recurse) {\n  if (recurse) {\n    // Take the table offline\n    var table = this.dom.tr.parentNode; // TODO: not nice to access the main table like this\n    var frame = table.parentNode;\n    var scrollTop = frame.scrollTop;\n    frame.removeChild(table);\n  }\n\n  if (this.expanded) {\n    this.collapse(recurse);\n  }\n  else {\n    this.expand(recurse);\n  }\n\n  if (recurse) {\n    // Put the table online again\n    frame.appendChild(table);\n    frame.scrollTop = scrollTop;\n  }\n};\n\n/**\n * Remove nodes\n * @param {Node[] | Node} nodes\n */\nNode.onRemove = function(nodes) {\n  if (!Array.isArray(nodes)) {\n    return Node.onRemove([nodes]);\n  }\n\n  if (nodes && nodes.length > 0) {\n    var firstNode = nodes[0];\n    var parent = firstNode.parent;\n    var editor = firstNode.editor;\n    var firstIndex = firstNode.getIndex();\n    editor.highlighter.unhighlight();\n\n    // adjust the focus\n    var oldSelection = editor.getDomSelection();\n    Node.blurNodes(nodes);\n    var newSelection = editor.getDomSelection();\n\n    // store the paths before removing them (needed for history)\n    var paths = nodes.map(getInternalPath);\n\n    // remove the nodes\n    nodes.forEach(function (node) {\n      node.parent._remove(node);\n    });\n\n    // store history action\n    editor._onAction('removeNodes', {\n      nodes: nodes,\n      paths: paths,\n      parentPath: parent.getInternalPath(),\n      index: firstIndex,\n      oldSelection: oldSelection,\n      newSelection: newSelection\n    });\n  }\n};\n\n\n/**\n * Duplicate nodes\n * duplicated nodes will be added right after the original nodes\n * @param {Node[] | Node} nodes\n */\nNode.onDuplicate = function(nodes) {\n  if (!Array.isArray(nodes)) {\n    return Node.onDuplicate([nodes]);\n  }\n\n  if (nodes && nodes.length > 0) {\n    var lastNode = nodes[nodes.length - 1];\n    var parent = lastNode.parent;\n    var editor = lastNode.editor;\n\n    editor.deselect(editor.multiselection.nodes);\n\n    // duplicate the nodes\n    var oldSelection = editor.getDomSelection();\n    var afterNode = lastNode;\n    var clones = nodes.map(function (node) {\n      var clone = node.clone();\n      parent.insertAfter(clone, afterNode);\n      afterNode = clone;\n      return clone;\n    });\n\n    // set selection to the duplicated nodes\n    if (nodes.length === 1) {\n      clones[0].focus();\n    }\n    else {\n      editor.select(clones);\n    }\n    var newSelection = editor.getDomSelection();\n\n    editor._onAction('duplicateNodes', {\n      paths: nodes.map(getInternalPath),\n      clonePaths: clones.map(getInternalPath),\n      afterPath: lastNode.getInternalPath(),\n      parentPath: parent.getInternalPath(),\n      oldSelection: oldSelection,\n      newSelection: newSelection\n    });\n  }\n};\n\n/**\n * Handle insert before event\n * @param {String} [field]\n * @param {*} [value]\n * @param {String} [type]   Can be 'auto', 'array', 'object', or 'string'\n * @private\n */\nNode.prototype._onInsertBefore = function (field, value, type) {\n  var oldSelection = this.editor.getDomSelection();\n\n  var newNode = new Node(this.editor, {\n    field: (field != undefined) ? field : '',\n    value: (value != undefined) ? value : '',\n    type: type\n  });\n  newNode.expand(true);\n\n  var beforePath = this.getInternalPath();\n\n  this.parent.insertBefore(newNode, this);\n  this.editor.highlighter.unhighlight();\n  newNode.focus('field');\n  var newSelection = this.editor.getDomSelection();\n\n  this.editor._onAction('insertBeforeNodes', {\n    nodes: [newNode],\n    paths: [newNode.getInternalPath()],\n    beforePath: beforePath,\n    parentPath: this.parent.getInternalPath(),\n    oldSelection: oldSelection,\n    newSelection: newSelection\n  });\n};\n\n/**\n * Handle insert after event\n * @param {String} [field]\n * @param {*} [value]\n * @param {String} [type]   Can be 'auto', 'array', 'object', or 'string'\n * @private\n */\nNode.prototype._onInsertAfter = function (field, value, type) {\n  var oldSelection = this.editor.getDomSelection();\n\n  var newNode = new Node(this.editor, {\n    field: (field != undefined) ? field : '',\n    value: (value != undefined) ? value : '',\n    type: type\n  });\n  newNode.expand(true);\n  this.parent.insertAfter(newNode, this);\n  this.editor.highlighter.unhighlight();\n  newNode.focus('field');\n  var newSelection = this.editor.getDomSelection();\n\n  this.editor._onAction('insertAfterNodes', {\n    nodes: [newNode],\n    paths: [newNode.getInternalPath()],\n    afterPath: this.getInternalPath(),\n    parentPath: this.parent.getInternalPath(),\n    oldSelection: oldSelection,\n    newSelection: newSelection\n  });\n};\n\n/**\n * Handle append event\n * @param {String} [field]\n * @param {*} [value]\n * @param {String} [type]   Can be 'auto', 'array', 'object', or 'string'\n * @private\n */\nNode.prototype._onAppend = function (field, value, type) {\n  var oldSelection = this.editor.getDomSelection();\n\n  var newNode = new Node(this.editor, {\n    field: (field != undefined) ? field : '',\n    value: (value != undefined) ? value : '',\n    type: type\n  });\n  newNode.expand(true);\n  this.parent.appendChild(newNode);\n  this.editor.highlighter.unhighlight();\n  newNode.focus('field');\n  var newSelection = this.editor.getDomSelection();\n\n  this.editor._onAction('appendNodes', {\n    nodes: [newNode],\n    paths: [newNode.getInternalPath()],\n    parentPath: this.parent.getInternalPath(),\n    oldSelection: oldSelection,\n    newSelection: newSelection\n  });\n};\n\n/**\n * Change the type of the node's value\n * @param {String} newType\n * @private\n */\nNode.prototype._onChangeType = function (newType) {\n  var oldType = this.type;\n  if (newType != oldType) {\n    var oldSelection = this.editor.getDomSelection();\n    this.changeType(newType);\n    var newSelection = this.editor.getDomSelection();\n\n    this.editor._onAction('changeType', {\n      path: this.getInternalPath(),\n      oldType: oldType,\n      newType: newType,\n      oldSelection: oldSelection,\n      newSelection: newSelection\n    });\n  }\n};\n\n/**\n * Sort the child's of the node. Only applicable when the node has type 'object'\n * or 'array'.\n * @param {String[]} path      Path of the child value to be compared\n * @param {String} direction   Sorting direction. Available values: \"asc\", \"desc\"\n * @private\n */\nNode.prototype.sort = function (path, direction) {\n  if (!this._hasChilds()) {\n    return;\n  }\n\n  this.hideChilds(); // sorting is faster when the childs are not attached to the dom\n\n  // copy the childs array (the old one will be kept for an undo action\n  var oldChilds = this.childs;\n  this.childs = this.childs.concat();\n\n  // sort the childs array\n  var order = (direction === 'desc') ? -1 : 1;\n\n  if (this.type === 'object') {\n    this.childs.sort(function (a, b) {\n      return order * naturalSort(a.field, b.field);\n    });\n  }\n  else { // this.type === 'array'\n    this.childs.sort(function (a, b) {\n      var nodeA = a.getNestedChild(path);\n      var nodeB = b.getNestedChild(path);\n\n      if (!nodeA) {\n        return order;\n      }\n      if (!nodeB) {\n        return -order;\n      }\n\n      var valueA = nodeA.value;\n      var valueB = nodeB.value;\n\n      if (typeof valueA !== 'string' && typeof valueB !== 'string') {\n        // both values are a number, boolean, or null -> use simple, fast sorting\n        return valueA > valueB ? order : valueA < valueB ? -order : 0;\n      }\n\n      return order * naturalSort(valueA, valueB);\n    });\n  }\n\n  // update the index numbering\n  this._updateDomIndexes();\n\n  this.editor._onAction('sort', {\n    path: this.getInternalPath(),\n    oldChilds: oldChilds,\n    newChilds: this.childs\n  });\n\n  this.showChilds();\n};\n\n/**\n * Replace the value of the node, keep it's state\n * @param {*} newValue\n */\nNode.prototype.update = function (newValue) {\n  var oldValue = this.getInternalValue();\n\n  this.setValue(newValue);\n\n  this.editor._onAction('transform', {\n    path: this.getInternalPath(),\n    oldValue: oldValue,\n    newValue: this.getInternalValue()\n  });\n};\n\n/**\n * Remove this node from the DOM\n * @returns {{table: Element, nextTr?: Element}}\n *            Returns the DOM elements that which be used to attach the node\n *            to the DOM again, see _attachToDom.\n * @private\n */\nNode.prototype._detachFromDom = function () {\n  var table = this.dom.tr ? this.dom.tr.parentNode : undefined;\n  var lastTr;\n  if (this.expanded) {\n    lastTr = this.getAppendDom();\n  }\n  else {\n    lastTr = this.getDom();\n  }\n  var nextTr = (lastTr && lastTr.parentNode) ? lastTr.nextSibling : undefined;\n\n  this.hide({ resetVisibleChilds: false });\n\n  return {\n    table: table,\n    nextTr: nextTr\n  }\n};\n\n/**\n * Attach this node to the DOM again\n * @param {{table: Element, nextTr?: Element}} domAnchor\n *            The DOM elements returned by _detachFromDom.\n * @private\n */\nNode.prototype._attachToDom = function (domAnchor) {\n  if (domAnchor.table) {\n    if (domAnchor.nextTr) {\n      domAnchor.table.insertBefore(this.getDom(), domAnchor.nextTr);\n    }\n    else {\n      domAnchor.table.appendChild(this.getDom());\n    }\n  }\n\n  if (this.expanded) {\n    this.showChilds();\n  }\n};\n\n/**\n * Transform the node given a JMESPath query.\n * @param {String} query    JMESPath query to apply\n * @private\n */\nNode.prototype.transform = function (query) {\n  if (!this._hasChilds()) {\n    return;\n  }\n\n  this.hideChilds(); // sorting is faster when the childs are not attached to the dom\n\n  try {\n    // apply the JMESPath query\n    var oldValue = this.getInternalValue();\n    var newValue = jmespath.search(oldValue, query);\n\n    this.setValue(newValue);\n\n    this.editor._onAction('transform', {\n      path: this.getInternalPath(),\n      oldValue: oldValue,\n      newValue: this.getInternalValue()\n    });\n\n    this.showChilds();\n  }\n  catch (err) {\n    this.showChilds();\n\n    this.editor._onError(err);\n  }\n};\n\n/**\n * Get a nested child given a path with properties\n * @param {String[]} path\n * @returns {Node}\n */\nNode.prototype.getNestedChild = function (path) {\n  var i = 0;\n  var child = this;\n\n  while (child && i < path.length) {\n    child = child.findChildByProperty(path[i]);\n    i++;\n  }\n\n  return child;\n};\n\n/**\n * Find a child by property name\n * @param {string} prop\n * @return {Node | undefined} Returns the child node when found, or undefined otherwise\n */\nNode.prototype.findChildByProperty = function(prop) {\n  if (this.type !== 'object') {\n    return undefined;\n  }\n\n  return this.childs.find(function (child) {\n    return child.field === prop;\n  });\n};\n\n/**\n * Get the child paths of this node\n * @param {boolean} [includeObjects=false] If true, object and array paths are returned as well\n * @return {string[]}\n */\nNode.prototype.getChildPaths = function (includeObjects) {\n  var pathsMap = {};\n\n  this._getChildPaths(pathsMap, '', includeObjects);\n\n  if (this.type === 'array') {\n    this.childs.forEach(function (child) {\n      child._getChildPaths(pathsMap, '', includeObjects);\n    });\n  }\n\n  return Object.keys(pathsMap).sort();\n};\n\n/**\n * Get the child paths of this node\n * @param {Object<String, boolean>} pathsMap\n * @param {boolean} [includeObjects=false]  If true, object and array paths are returned as well\n * @param {string} rootPath\n */\nNode.prototype._getChildPaths = function (pathsMap, rootPath, includeObjects) {\n  if (this.type === 'auto' || this.type === 'string' || includeObjects) {\n    pathsMap[rootPath || '.'] = true;\n  }\n\n  if (this.type === 'object') {\n    this.childs.forEach(function (child) {\n      child._getChildPaths(pathsMap, rootPath + '.' + child.field, includeObjects);\n    });\n  }\n};\n\n/**\n * Create a table row with an append button.\n * @return {HTMLElement | undefined} tr with the AppendNode contents\n */\nNode.prototype.getAppendDom = function () {\n  if (!this.append) {\n    this.append = new AppendNode(this.editor);\n    this.append.setParent(this);\n  }\n  return this.append.getDom();\n};\n\n/**\n * Create a table row with an showMore button and text\n * @return {HTMLElement | undefined} tr with the AppendNode contents\n */\nNode.prototype.getShowMoreDom = function () {\n  if (!this.showMore) {\n    this.showMore = new ShowMoreNode(this.editor, this);\n  }\n  return this.showMore.getDom();\n};\n\n/**\n * Find the node from an event target\n * @param {Node} target\n * @return {Node | undefined} node  or undefined when not found\n * @static\n */\nNode.getNodeFromTarget = function (target) {\n  while (target) {\n    if (target.node) {\n      return target.node;\n    }\n    target = target.parentNode;\n  }\n\n  return undefined;\n};\n\n/**\n * Remove the focus of given nodes, and move the focus to the (a) node before,\n * (b) the node after, or (c) the parent node.\n * @param {Array.<Node> | Node} nodes\n */\nNode.blurNodes = function (nodes) {\n  if (!Array.isArray(nodes)) {\n    Node.blurNodes([nodes]);\n    return;\n  }\n\n  var firstNode = nodes[0];\n  var parent = firstNode.parent;\n  var firstIndex = firstNode.getIndex();\n\n  if (parent.childs[firstIndex + nodes.length]) {\n    parent.childs[firstIndex + nodes.length].focus();\n  }\n  else if (parent.childs[firstIndex - 1]) {\n    parent.childs[firstIndex - 1].focus();\n  }\n  else {\n    parent.focus();\n  }\n};\n\n/**\n * Get the next sibling of current node\n * @return {Node} nextSibling\n */\nNode.prototype.nextSibling = function () {\n  var index = this.parent.childs.indexOf(this);\n  return this.parent.childs[index + 1] || this.parent.append;\n};\n\n/**\n * Get the previously rendered node\n * @return {Node | null} previousNode\n */\nNode.prototype._previousNode = function () {\n  var prevNode = null;\n  var dom = this.getDom();\n  if (dom && dom.parentNode) {\n    // find the previous field\n    var prevDom = dom;\n    do {\n      prevDom = prevDom.previousSibling;\n      prevNode = Node.getNodeFromTarget(prevDom);\n    }\n    while (prevDom && prevNode && (prevNode instanceof AppendNode && !prevNode.isVisible()));\n  }\n  return prevNode;\n};\n\n/**\n * Get the next rendered node\n * @return {Node | null} nextNode\n * @private\n */\nNode.prototype._nextNode = function () {\n  var nextNode = null;\n  var dom = this.getDom();\n  if (dom && dom.parentNode) {\n    // find the previous field\n    var nextDom = dom;\n    do {\n      nextDom = nextDom.nextSibling;\n      nextNode = Node.getNodeFromTarget(nextDom);\n    }\n    while (nextDom && nextNode && (nextNode instanceof AppendNode && !nextNode.isVisible()));\n  }\n\n  return nextNode;\n};\n\n/**\n * Get the first rendered node\n * @return {Node | null} firstNode\n * @private\n */\nNode.prototype._firstNode = function () {\n  var firstNode = null;\n  var dom = this.getDom();\n  if (dom && dom.parentNode) {\n    var firstDom = dom.parentNode.firstChild;\n    firstNode = Node.getNodeFromTarget(firstDom);\n  }\n\n  return firstNode;\n};\n\n/**\n * Get the last rendered node\n * @return {Node | null} lastNode\n * @private\n */\nNode.prototype._lastNode = function () {\n  var lastNode = null;\n  var dom = this.getDom();\n  if (dom && dom.parentNode) {\n    var lastDom = dom.parentNode.lastChild;\n    lastNode =  Node.getNodeFromTarget(lastDom);\n    while (lastDom && lastNode && !lastNode.isVisible()) {\n      lastDom = lastDom.previousSibling;\n      lastNode =  Node.getNodeFromTarget(lastDom);\n    }\n  }\n  return lastNode;\n};\n\n/**\n * Get the next element which can have focus.\n * @param {Element} elem\n * @return {Element | null} nextElem\n * @private\n */\nNode.prototype._previousElement = function (elem) {\n  var dom = this.dom;\n  // noinspection FallthroughInSwitchStatementJS\n  switch (elem) {\n    case dom.value:\n      if (this.fieldEditable) {\n        return dom.field;\n      }\n    // intentional fall through\n    case dom.field:\n      if (this._hasChilds()) {\n        return dom.expand;\n      }\n    // intentional fall through\n    case dom.expand:\n      return dom.menu;\n    case dom.menu:\n      if (dom.drag) {\n        return dom.drag;\n      }\n    // intentional fall through\n    default:\n      return null;\n  }\n};\n\n/**\n * Get the next element which can have focus.\n * @param {Element} elem\n * @return {Element | null} nextElem\n * @private\n */\nNode.prototype._nextElement = function (elem) {\n  var dom = this.dom;\n  // noinspection FallthroughInSwitchStatementJS\n  switch (elem) {\n    case dom.drag:\n      return dom.menu;\n    case dom.menu:\n      if (this._hasChilds()) {\n        return dom.expand;\n      }\n    // intentional fall through\n    case dom.expand:\n      if (this.fieldEditable) {\n        return dom.field;\n      }\n    // intentional fall through\n    case dom.field:\n      if (!this._hasChilds()) {\n        return dom.value;\n      }\n    default:\n      return null;\n  }\n};\n\n/**\n * Get the dom name of given element. returns null if not found.\n * For example when element == dom.field, \"field\" is returned.\n * @param {Element} element\n * @return {String | null} elementName  Available elements with name: 'drag',\n *                                      'menu', 'expand', 'field', 'value'\n * @private\n */\nNode.prototype._getElementName = function (element) {\n  var dom = this.dom;\n  for (var name in dom) {\n    if (dom.hasOwnProperty(name)) {\n      if (dom[name] == element) {\n        return name;\n      }\n    }\n  }\n  return null;\n};\n\n/**\n * Test if this node has childs. This is the case when the node is an object\n * or array.\n * @return {boolean} hasChilds\n * @private\n */\nNode.prototype._hasChilds = function () {\n  return this.type == 'array' || this.type == 'object';\n};\n\n// titles with explanation for the different types\nNode.TYPE_TITLES = {\n  'auto': translate('autoType'),\n  'object': translate('objectType'),\n  'array': translate('arrayType'),\n  'string': translate('stringType')\n};\n\nNode.prototype.addTemplates = function (menu, append) {\n    var node = this;\n    var templates = node.editor.options.templates;\n    if (templates == null) return;\n    if (templates.length) {\n        // create a separator\n        menu.push({\n            'type': 'separator'\n        });\n    }\n    var appendData = function (name, data) {\n        node._onAppend(name, data);\n    };\n    var insertData = function (name, data) {\n        node._onInsertBefore(name, data);\n    };\n    templates.forEach(function (template) {\n        menu.push({\n            text: template.text,\n            className: (template.className || 'jsoneditor-type-object'),\n            title: template.title,\n            click: (append ? appendData.bind(this, template.field, template.value) : insertData.bind(this, template.field, template.value))\n        });\n    });\n};\n\n/**\n * Show a contextmenu for this node\n * @param {HTMLElement} anchor   Anchor element to attach the context menu to\n *                               as sibling.\n * @param {function} [onClose]   Callback method called when the context menu\n *                               is being closed.\n */\nNode.prototype.showContextMenu = function (anchor, onClose) {\n  var node = this;\n  var titles = Node.TYPE_TITLES;\n  var items = [];\n\n  if (this.editable.value) {\n    items.push({\n      text: translate('type'),\n      title: translate('typeTitle'),\n      className: 'jsoneditor-type-' + this.type,\n      submenu: [\n        {\n          text: translate('auto'),\n          className: 'jsoneditor-type-auto' +\n              (this.type == 'auto' ? ' jsoneditor-selected' : ''),\n          title: titles.auto,\n          click: function () {\n            node._onChangeType('auto');\n          }\n        },\n        {\n          text: translate('array'),\n          className: 'jsoneditor-type-array' +\n              (this.type == 'array' ? ' jsoneditor-selected' : ''),\n          title: titles.array,\n          click: function () {\n            node._onChangeType('array');\n          }\n        },\n        {\n          text: translate('object'),\n          className: 'jsoneditor-type-object' +\n              (this.type == 'object' ? ' jsoneditor-selected' : ''),\n          title: titles.object,\n          click: function () {\n            node._onChangeType('object');\n          }\n        },\n        {\n          text: translate('string'),\n          className: 'jsoneditor-type-string' +\n              (this.type == 'string' ? ' jsoneditor-selected' : ''),\n          title: titles.string,\n          click: function () {\n            node._onChangeType('string');\n          }\n        }\n      ]\n    });\n  }\n\n  if (this._hasChilds()) {\n    items.push({\n      text: translate('sort'),\n      title: translate('sortTitle', {type: this.type}),\n      className: 'jsoneditor-sort-asc',\n      click: function () {\n        var anchor = node.editor.options.modalAnchor || DEFAULT_MODAL_ANCHOR;\n        showSortModal(node, anchor)\n      }\n    });\n\n    items.push({\n      text: translate('transform'),\n      title: translate('transformTitle', {type: this.type}),\n      className: 'jsoneditor-transform',\n      click: function () {\n        var anchor = node.editor.options.modalAnchor || DEFAULT_MODAL_ANCHOR;\n        showTransformModal(node, anchor)\n      }\n    });\n  }\n\n  if (this.parent && this.parent._hasChilds()) {\n    if (items.length) {\n      // create a separator\n      items.push({\n        'type': 'separator'\n      });\n    }\n\n    // create append button (for last child node only)\n    var childs = node.parent.childs;\n    if (node == childs[childs.length - 1]) {\n        var appendSubmenu = [\n            {\n                text: translate('auto'),\n                className: 'jsoneditor-type-auto',\n                title: titles.auto,\n                click: function () {\n                    node._onAppend('', '', 'auto');\n                }\n            },\n            {\n                text: translate('array'),\n                className: 'jsoneditor-type-array',\n                title: titles.array,\n                click: function () {\n                    node._onAppend('', []);\n                }\n            },\n            {\n                text: translate('object'),\n                className: 'jsoneditor-type-object',\n                title: titles.object,\n                click: function () {\n                    node._onAppend('', {});\n                }\n            },\n            {\n                text: translate('string'),\n                className: 'jsoneditor-type-string',\n                title: titles.string,\n                click: function () {\n                    node._onAppend('', '', 'string');\n                }\n            }\n        ];\n        node.addTemplates(appendSubmenu, true);\n        items.push({\n            text: translate('appendText'),\n            title: translate('appendTitle'),\n            submenuTitle: translate('appendSubmenuTitle'),\n            className: 'jsoneditor-append',\n            click: function () {\n                node._onAppend('', '', 'auto');\n            },\n            submenu: appendSubmenu\n        });\n    }\n\n\n\n    // create insert button\n    var insertSubmenu = [\n        {\n            text: translate('auto'),\n            className: 'jsoneditor-type-auto',\n            title: titles.auto,\n            click: function () {\n                node._onInsertBefore('', '', 'auto');\n            }\n        },\n        {\n            text: translate('array'),\n            className: 'jsoneditor-type-array',\n            title: titles.array,\n            click: function () {\n                node._onInsertBefore('', []);\n            }\n        },\n        {\n            text: translate('object'),\n            className: 'jsoneditor-type-object',\n            title: titles.object,\n            click: function () {\n                node._onInsertBefore('', {});\n            }\n        },\n        {\n            text: translate('string'),\n            className: 'jsoneditor-type-string',\n            title: titles.string,\n            click: function () {\n                node._onInsertBefore('', '', 'string');\n            }\n        }\n    ];\n    node.addTemplates(insertSubmenu, false);\n    items.push({\n      text: translate('insert'),\n      title: translate('insertTitle'),\n      submenuTitle: translate('insertSub'),\n      className: 'jsoneditor-insert',\n      click: function () {\n        node._onInsertBefore('', '', 'auto');\n      },\n      submenu: insertSubmenu\n    });\n\n    if (this.editable.field) {\n      // create duplicate button\n      items.push({\n        text: translate('duplicateText'),\n        title: translate('duplicateField'),\n        className: 'jsoneditor-duplicate',\n        click: function () {\n          Node.onDuplicate(node);\n        }\n      });\n\n      // create remove button\n      items.push({\n        text: translate('removeText'),\n        title: translate('removeField'),\n        className: 'jsoneditor-remove',\n        click: function () {\n          Node.onRemove(node);\n        }\n      });\n    }\n  }\n\n  var menu = new ContextMenu(items, {close: onClose});\n  menu.show(anchor, this.editor.content);\n};\n\n/**\n * get the type of a value\n * @param {*} value\n * @return {String} type   Can be 'object', 'array', 'string', 'auto'\n * @private\n */\nNode.prototype._getType = function(value) {\n  if (value instanceof Array) {\n    return 'array';\n  }\n  if (value instanceof Object) {\n    return 'object';\n  }\n  if (typeof(value) == 'string' && typeof(this._stringCast(value)) != 'string') {\n    return 'string';\n  }\n\n  return 'auto';\n};\n\n/**\n * cast contents of a string to the correct type. This can be a string,\n * a number, a boolean, etc\n * @param {String} str\n * @return {*} castedStr\n * @private\n */\nNode.prototype._stringCast = function(str) {\n  var lower = str.toLowerCase(),\n      num = Number(str),          // will nicely fail with '123ab'\n      numFloat = parseFloat(str); // will nicely fail with '  '\n\n  if (str == '') {\n    return '';\n  }\n  else if (lower == 'null') {\n    return null;\n  }\n  else if (lower == 'true') {\n    return true;\n  }\n  else if (lower == 'false') {\n    return false;\n  }\n  else if (!isNaN(num) && !isNaN(numFloat)) {\n    return num;\n  }\n  else {\n    return str;\n  }\n};\n\n/**\n * escape a text, such that it can be displayed safely in an HTML element\n * @param {String} text\n * @return {String} escapedText\n * @private\n */\nNode.prototype._escapeHTML = function (text) {\n  if (typeof text !== 'string') {\n    return String(text);\n  }\n  else {\n    var htmlEscaped = String(text)\n        .replace(/&/g, '&amp;')    // must be replaced first!\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/  /g, ' &nbsp;') // replace double space with an nbsp and space\n        .replace(/^ /, '&nbsp;')   // space at start\n        .replace(/ $/, '&nbsp;');  // space at end\n\n    var json = JSON.stringify(htmlEscaped);\n    var html = json.substring(1, json.length - 1);\n    if (this.editor.options.escapeUnicode === true) {\n      html = util.escapeUnicodeChars(html);\n    }\n    return html;\n  }\n};\n\n/**\n * unescape a string.\n * @param {String} escapedText\n * @return {String} text\n * @private\n */\nNode.prototype._unescapeHTML = function (escapedText) {\n  var json = '\"' + this._escapeJSON(escapedText) + '\"';\n  var htmlEscaped = util.parse(json);\n\n  return htmlEscaped\n      .replace(/&lt;/g, '<')\n      .replace(/&gt;/g, '>')\n      .replace(/&nbsp;|\\u00A0/g, ' ')\n      .replace(/&amp;/g, '&');   // must be replaced last\n};\n\n/**\n * escape a text to make it a valid JSON string. The method will:\n *   - replace unescaped double quotes with '\\\"'\n *   - replace unescaped backslash with '\\\\'\n *   - replace returns with '\\n'\n * @param {String} text\n * @return {String} escapedText\n * @private\n */\nNode.prototype._escapeJSON = function (text) {\n  // TODO: replace with some smart regex (only when a new solution is faster!)\n  var escaped = '';\n  var i = 0;\n  while (i < text.length) {\n    var c = text.charAt(i);\n    if (c == '\\n') {\n      escaped += '\\\\n';\n    }\n    else if (c == '\\\\') {\n      escaped += c;\n      i++;\n\n      c = text.charAt(i);\n      if (c === '' || '\"\\\\/bfnrtu'.indexOf(c) == -1) {\n        escaped += '\\\\';  // no valid escape character\n      }\n      escaped += c;\n    }\n    else if (c == '\"') {\n      escaped += '\\\\\"';\n    }\n    else {\n      escaped += c;\n    }\n    i++;\n  }\n\n  return escaped;\n};\n\n// helper function to get the internal path of a node\nfunction getInternalPath (node) {\n  return node.getInternalPath();\n}\n\n// helper function to get the field of a node\nfunction getField (node) {\n  return node.getField();\n}\n\n// TODO: find a nicer solution to resolve this circular dependency between Node and AppendNode\n//       idea: introduce properties .isAppendNode and .isNode and use that instead of instanceof AppendNode checks\nvar AppendNode = appendNodeFactory(Node);\nvar ShowMoreNode = showMoreNodeFactory(Node);\n\nmodule.exports = Node;\n",null]}